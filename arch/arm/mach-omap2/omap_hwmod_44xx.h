/*
 * OMAP4 hardware modules present on the OMAP44xx chips
 *
 * Copyright (C) 2009-2010 Texas Instruments, Inc.
 * Copyright (C) 2009-2010 Nokia Corporation
 *
 * Paul Walmsley
 * Benoit Cousson
 *
 * This file is automatically generated from the OMAP hardware databases.
 * We respectfully ask that any modifications to this file be coordinated
 * with the public linux-omap@vger.kernel.org mailing list and the
 * authors above to ensure that the autogeneration scripts are kept
 * up-to-date with the file contents.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation.
 */

#ifndef __ARCH_ARM_MACH_OMAP2_OMAP_HWMOD_44XX_H
#define __ARCH_ARM_MACH_OMAP2_OMAP_HWMOD_44XX_H

#ifdef CONFIG_ARCH_OMAP4

#include <plat/omap_hwmod.h>
#include <plat/cpu.h>

#include "prcm-common.h"
#include "prm-regbits-44xx.h"
#include "irqs-44xx.h"
#include "dma-44xx.h"

/* Backward references (IPs with Bus Master capability) */
static struct omap_hwmod omap44xx_aess_hwmod;
static struct omap_hwmod omap44xx_cryptodma_hwmod;
static struct omap_hwmod omap44xx_debug_logic_hwmod;
static struct omap_hwmod omap44xx_dmm_hwmod;
static struct omap_hwmod omap44xx_dss_hwmod;
static struct omap_hwmod omap44xx_ducati_hwmod;
static struct omap_hwmod omap44xx_emif_fw_hwmod;
static struct omap_hwmod omap44xx_fdif_hwmod;
static struct omap_hwmod omap44xx_gfx_hwmod;
static struct omap_hwmod omap44xx_hsi_hwmod;
static struct omap_hwmod omap44xx_iss_hwmod;
static struct omap_hwmod omap44xx_ivahd_hwmod;
static struct omap_hwmod omap44xx_l3_instr_hwmod;
static struct omap_hwmod omap44xx_l3_1_hwmod;
static struct omap_hwmod omap44xx_l3_2_hwmod;
static struct omap_hwmod omap44xx_l3_3_hwmod;
static struct omap_hwmod omap44xx_l4_audio_hwmod;
static struct omap_hwmod omap44xx_l4_cfg_hwmod;
static struct omap_hwmod omap44xx_l4_per_hwmod;
static struct omap_hwmod omap44xx_l4_wkup_hwmod;
static struct omap_hwmod omap44xx_mmc1_hwmod;
static struct omap_hwmod omap44xx_mmc2_hwmod;
static struct omap_hwmod omap44xx_mpuss_hwmod;
static struct omap_hwmod omap44xx_ocp_wp1_hwmod;
static struct omap_hwmod omap44xx_sad2d_hwmod;
static struct omap_hwmod omap44xx_sad2d_fw_hwmod;
static struct omap_hwmod omap44xx_sdma_hwmod;
static struct omap_hwmod omap44xx_sl2_hwmod;
static struct omap_hwmod omap44xx_tesla_hwmod;
static struct omap_hwmod omap44xx_unipro1_hwmod;
static struct omap_hwmod omap44xx_usb_host_hwmod;
static struct omap_hwmod omap44xx_usb_host_fs_hwmod;
static struct omap_hwmod omap44xx_usb_otg_hwmod;

/* Dump all interconnects structures */

/* dmm interface data */
/* l3_1 -> dmm */
static struct omap_hwmod_ocp_if omap44xx_l3_1__dmm = {
	.master		= &omap44xx_l3_1_hwmod,
	.slave		= &omap44xx_dmm_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mpuss -> dmm */
static struct omap_hwmod_ocp_if omap44xx_mpuss__dmm = {
	.master		= &omap44xx_mpuss_hwmod,
	.slave		= &omap44xx_dmm_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_mpu_m2_ck",
	.user		= OCP_USER_MPU,
};

/* dmm slave ports */
static struct omap_hwmod_ocp_if *omap44xx_dmm_slaves[] = {
	&omap44xx_l3_1__dmm,
	&omap44xx_mpuss__dmm,
};

static struct omap_hwmod omap44xx_dmm_hwmod = {
	.name		= "dmm",
	.slaves		= omap44xx_dmm_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_dmm_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l3_instr_interconnect interface data */
/* ocp_wp1 -> l3_instr */
static struct omap_hwmod_ocp_if omap44xx_ocp_wp1__l3_instr = {
	.master		= &omap44xx_ocp_wp1_hwmod,
	.slave		= &omap44xx_l3_instr_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_3 -> l3_instr */
static struct omap_hwmod_ocp_if omap44xx_l3_3__l3_instr = {
	.master		= &omap44xx_l3_3_hwmod,
	.slave		= &omap44xx_l3_instr_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ivahd -> l3_instr */
static struct omap_hwmod_ocp_if omap44xx_ivahd__l3_instr = {
	.master		= &omap44xx_ivahd_hwmod,
	.slave		= &omap44xx_l3_instr_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m5_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_instr slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l3_instr_slaves[] = {
	&omap44xx_ocp_wp1__l3_instr,
	&omap44xx_l3_3__l3_instr,
	&omap44xx_ivahd__l3_instr,
};

static struct omap_hwmod omap44xx_l3_instr_hwmod = {
	.name		= "l3_instr",
	.slaves		= omap44xx_l3_instr_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l3_instr_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l3_interconnect_1 interface data */
/* mmc2 -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_mmc2__l3_1 = {
	.master		= &omap44xx_mmc2_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc1 -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_mmc1__l3_1 = {
	.master		= &omap44xx_mmc1_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* tesla -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_tesla__l3_1 = {
	.master		= &omap44xx_tesla_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m4_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_cfg -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__l3_1 = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_2 -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_l3_2__l3_1 = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* dss -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_dss__l3_1 = {
	.master		= &omap44xx_dss_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mpuss -> l3_1 */
static struct omap_hwmod_ocp_if omap44xx_mpuss__l3_1 = {
	.master		= &omap44xx_mpuss_hwmod,
	.slave		= &omap44xx_l3_1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_mpu_m2_ck",
	.user		= OCP_USER_MPU,
};

/* l3_1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l3_1_slaves[] = {
	&omap44xx_mmc2__l3_1,
	&omap44xx_mmc1__l3_1,
	&omap44xx_tesla__l3_1,
	&omap44xx_l4_cfg__l3_1,
	&omap44xx_l3_2__l3_1,
	&omap44xx_dss__l3_1,
	&omap44xx_mpuss__l3_1,
};

static struct omap_hwmod_irq_info omap44xx_l3_1_irqs[] = {
};

static struct omap_hwmod omap44xx_l3_1_hwmod = {
	.name		= "l3_1",
	.slaves		= omap44xx_l3_1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l3_1_slaves),
	.mpu_irqs	= omap44xx_l3_1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_l3_1_irqs),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l3_interconnect_2 interface data */
/* gfx -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_gfx__l3_2 = {
	.master		= &omap44xx_gfx_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* fdif -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_fdif__l3_2 = {
	.master		= &omap44xx_fdif_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "fdif_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_otg -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_usb_otg__l3_2 = {
	.master		= &omap44xx_usb_otg_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* iss -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_iss__l3_2 = {
	.master		= &omap44xx_iss_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ducati_clk_mux_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* hsi -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_hsi__l3_2 = {
	.master		= &omap44xx_hsi_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_host_fs -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_usb_host_fs__l3_2 = {
	.master		= &omap44xx_usb_host_fs_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* cryptodma -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_cryptodma__l3_2 = {
	.master		= &omap44xx_cryptodma_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ivahd -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_ivahd__l3_2 = {
	.master		= &omap44xx_ivahd_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m5_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* debug_logic -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_debug_logic__l3_2 = {
	.master		= &omap44xx_debug_logic_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dbgclk_mux_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ducati -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_ducati__l3_2 = {
	.master		= &omap44xx_ducati_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ducati_clk_mux_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* unipro1 -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_unipro1__l3_2 = {
	.master		= &omap44xx_unipro1_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_cfg -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__l3_2 = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sdma -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_sdma__l3_2 = {
	.master		= &omap44xx_sdma_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_host -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_usb_host__l3_2 = {
	.master		= &omap44xx_usb_host_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_1 -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_l3_1__l3_2 = {
	.master		= &omap44xx_l3_1_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sad2d_fw -> l3_2 */
static struct omap_hwmod_ocp_if omap44xx_sad2d_fw__l3_2 = {
	.master		= &omap44xx_sad2d_fw_hwmod,
	.slave		= &omap44xx_l3_2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l3_2_slaves[] = {
	&omap44xx_gfx__l3_2,
	&omap44xx_fdif__l3_2,
	&omap44xx_usb_otg__l3_2,
	&omap44xx_iss__l3_2,
	&omap44xx_hsi__l3_2,
	&omap44xx_usb_host_fs__l3_2,
	&omap44xx_cryptodma__l3_2,
	&omap44xx_ivahd__l3_2,
	&omap44xx_debug_logic__l3_2,
	&omap44xx_ducati__l3_2,
	&omap44xx_unipro1__l3_2,
	&omap44xx_l4_cfg__l3_2,
	&omap44xx_sdma__l3_2,
	&omap44xx_usb_host__l3_2,
	&omap44xx_l3_1__l3_2,
	&omap44xx_sad2d_fw__l3_2,
};

static struct omap_hwmod_irq_info omap44xx_l3_2_irqs[] = {
};

static struct omap_hwmod omap44xx_l3_2_hwmod = {
	.name		= "l3_2",
	.slaves		= omap44xx_l3_2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l3_2_slaves),
	.mpu_irqs	= omap44xx_l3_2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_l3_2_irqs),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l3_interconnect_3 interface data */
/* l4_cfg -> l3_3 */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__l3_3 = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_l3_3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_2 -> l3_3 */
static struct omap_hwmod_ocp_if omap44xx_l3_2__l3_3 = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_l3_3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_1 -> l3_3 */
static struct omap_hwmod_ocp_if omap44xx_l3_1__l3_3 = {
	.master		= &omap44xx_l3_1_hwmod,
	.slave		= &omap44xx_l3_3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l3_3_slaves[] = {
	&omap44xx_l4_cfg__l3_3,
	&omap44xx_l3_2__l3_3,
	&omap44xx_l3_1__l3_3,
};

static struct omap_hwmod_irq_info omap44xx_l3_3_irqs[] = {
	{ .name = "int_dbg", .irq = OMAP44XX_IRQ_L3_DBG }, /* 9 */
	{ .name = "int_err", .irq = OMAP44XX_IRQ_L3_APP }, /* 10 */
};

static struct omap_hwmod omap44xx_l3_3_hwmod = {
	.name		= "l3_3",
	.slaves		= omap44xx_l3_3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l3_3_slaves),
	.mpu_irqs	= omap44xx_l3_3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_l3_3_irqs),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l4_audio_interconnect interface data */
/* tesla -> l4_audio */
static struct omap_hwmod_ocp_if omap44xx_tesla__l4_audio = {
	.master		= &omap44xx_tesla_hwmod,
	.slave		= &omap44xx_l4_audio_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m4_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mpuss -> l4_audio */
static struct omap_hwmod_ocp_if omap44xx_mpuss__l4_audio = {
	.master		= &omap44xx_mpuss_hwmod,
	.slave		= &omap44xx_l4_audio_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_mpu_m2_ck",
	.user		= OCP_USER_MPU,
};

/* aess -> l4_audio */
static struct omap_hwmod_ocp_if omap44xx_aess__l4_audio = {
	.master		= &omap44xx_aess_hwmod,
	.slave		= &omap44xx_l4_audio_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "aess_fclk",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_1 -> l4_audio */
static struct omap_hwmod_ocp_if omap44xx_l3_1__l4_audio = {
	.master		= &omap44xx_l3_1_hwmod,
	.slave		= &omap44xx_l4_audio_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_audio slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l4_audio_slaves[] = {
	&omap44xx_tesla__l4_audio,
	&omap44xx_mpuss__l4_audio,
	&omap44xx_aess__l4_audio,
	&omap44xx_l3_1__l4_audio,
};

static struct omap_hwmod omap44xx_l4_audio_hwmod = {
	.name		= "l4_audio",
	.slaves		= omap44xx_l4_audio_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l4_audio_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l4_cfg_interconnect interface data */
/* l3_1 -> l4_cfg */
static struct omap_hwmod_ocp_if omap44xx_l3_1__l4_cfg = {
	.master		= &omap44xx_l3_1_hwmod,
	.slave		= &omap44xx_l4_cfg_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_cfg slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l4_cfg_slaves[] = {
	&omap44xx_l3_1__l4_cfg,
};

static struct omap_hwmod omap44xx_l4_cfg_hwmod = {
	.name		= "l4_cfg",
	.slaves		= omap44xx_l4_cfg_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l4_cfg_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l4_per_interconnect interface data */
/* l3_2 -> l4_per */
static struct omap_hwmod_ocp_if omap44xx_l3_2__l4_per = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_l4_per_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_per slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l4_per_slaves[] = {
	&omap44xx_l3_2__l4_per,
};

static struct omap_hwmod omap44xx_l4_per_hwmod = {
	.name		= "l4_per",
	.slaves		= omap44xx_l4_per_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l4_per_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* l4_wkup_interconnect interface data */
/* l4_cfg -> l4_wkup */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__l4_wkup = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_l4_wkup_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l4_wkup slave ports */
static struct omap_hwmod_ocp_if *omap44xx_l4_wkup_slaves[] = {
	&omap44xx_l4_cfg__l4_wkup,
};

static struct omap_hwmod omap44xx_l4_wkup_hwmod = {
	.name		= "l4_wkup",
	.slaves		= omap44xx_l4_wkup_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_l4_wkup_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* sad2d_fw interface data */
/* l4_cfg -> sad2d_fw */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__sad2d_fw = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_sad2d_fw_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sad2d -> sad2d_fw */
static struct omap_hwmod_ocp_if omap44xx_sad2d__sad2d_fw = {
	.master		= &omap44xx_sad2d_hwmod,
	.slave		= &omap44xx_sad2d_fw_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sad2d_fw slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sad2d_fw_slaves[] = {
	&omap44xx_l4_cfg__sad2d_fw,
	&omap44xx_sad2d__sad2d_fw,
};

static struct omap_hwmod omap44xx_sad2d_fw_hwmod = {
	.name		= "sad2d_fw",
	.slaves		= omap44xx_sad2d_fw_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sad2d_fw_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* Dump all modules hwmod structures */

/* master_peripheral category */

/* aess */
static struct omap_hwmod_irq_info omap44xx_aess_irqs[] = {
	{ .name = "aess_irq_mpu", .irq = OMAP44XX_IRQ_ABE }, /* 99 */
};

static struct omap_hwmod_dma_info omap44xx_aess_sdma_chs[] = {
	{ .name = "aess_dmareq_5", .dma_ch = OMAP44XX_DMA_ABE_REQ_5 }, /* 105 */
	{ .name = "aess_dmareq_4", .dma_ch = OMAP44XX_DMA_ABE_REQ_4 }, /* 104 */
	{ .name = "aess_dmareq_7", .dma_ch = OMAP44XX_DMA_ABE_REQ_7 }, /* 107 */
	{ .name = "aess_dmareq_6", .dma_ch = OMAP44XX_DMA_ABE_REQ_6 }, /* 106 */
	{ .name = "aess_dmareq_1", .dma_ch = OMAP44XX_DMA_ABE_REQ_1 }, /* 101 */
	{ .name = "aess_dmareq_0", .dma_ch = OMAP44XX_DMA_ABE_REQ_0 }, /* 100 */
	{ .name = "aess_dmareq_3", .dma_ch = OMAP44XX_DMA_ABE_REQ_3 }, /* 103 */
	{ .name = "aess_dmareq_2", .dma_ch = OMAP44XX_DMA_ABE_REQ_2 }, /* 102 */
};

static struct omap_hwmod_addr_space omap44xx_aess_addrs[] = {
	{
		.pa_start	= 0x401f1000,
		.pa_end		= 0x401f11ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* aess master ports */
static struct omap_hwmod_ocp_if *omap44xx_aess_masters[] = {
	&omap44xx_aess__l4_audio,
};

/* l4_audio -> aess */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__aess = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_aess_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_aess_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_aess_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* aess slave ports */
static struct omap_hwmod_ocp_if *omap44xx_aess_slaves[] = {
	&omap44xx_l4_audio__aess,
};

static struct omap_hwmod_sysconfig omap44xx_aess_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_aess_hwmod = {
	.name		= "aess",
	.mpu_irqs	= omap44xx_aess_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_aess_irqs),
	.sdma_chs	= omap44xx_aess_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_aess_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "aess_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_AESS_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_aess_sysc,
	.slaves		= omap44xx_aess_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_aess_slaves),
	.masters	= omap44xx_aess_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_aess_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* dss */
static struct omap_hwmod_irq_info omap44xx_dss_irqs[] = {
	{ .name = "dss_dsi2_int", .irq = OMAP44XX_IRQ_DSS_DSI2 }, /* 84 */
	{ .name = "dss_dsi1_int", .irq = OMAP44XX_IRQ_DSS_DSI1 }, /* 53 */
	{ .name = "dss_hdmi_int", .irq = OMAP44XX_IRQ_DSS_HDMI }, /* 101 */
	{ .name = "dss_dispc_int", .irq = OMAP44XX_IRQ_DSS_DISPC }, /* 25 */
};

static struct omap_hwmod_dma_info omap44xx_dss_sdma_chs[] = {
	{ .name = "dss_dsi2_dma_req_2", .dma_ch = OMAP44XX_DMA_DSS_DSI2_REQ2 }, /* 82 */
	{ .name = "dss_dsi2_dma_req_3", .dma_ch = OMAP44XX_DMA_DSS_DSI2_REQ3 }, /* 83 */
	{ .name = "dss_dsi2_dma_req_0", .dma_ch = OMAP44XX_DMA_DSS_DSI2_REQ0 }, /* 80 */
	{ .name = "dss_dispc_dma_req", .dma_ch = OMAP44XX_DMA_DSS_DISPC_REQ }, /* 5 */
	{ .name = "dss_dsi2_dma_req_1", .dma_ch = OMAP44XX_DMA_DSS_DSI2_REQ1 }, /* 81 */
	{ .name = "dss_dsi1_dma_req_1", .dma_ch = OMAP44XX_DMA_DSS_DSI1_REQ1 }, /* 72 */
	{ .name = "dss_dsi1_dma_req_0", .dma_ch = OMAP44XX_DMA_DSS_DSI1_REQ0 }, /* 71 */
	{ .name = "dss_dsi1_dma_req_3", .dma_ch = OMAP44XX_DMA_DSS_DSI1_REQ3 }, /* 74 */
	{ .name = "dss_dsi1_dma_req_2", .dma_ch = OMAP44XX_DMA_DSS_DSI1_REQ2 }, /* 73 */
	{ .name = "dss_rfbi_dma_req", .dma_ch = OMAP44XX_DMA_DSS_RFBI_REQ }, /* 13 */
	{ .name = "dss_hdmi_dma_req", .dma_ch = OMAP44XX_DMA_DSS_HDMI_REQ }, /* 75 */
};

static struct omap_hwmod_addr_space omap44xx_dss_addrs[] = {
	{
		.pa_start	= 0x48040000,
		.pa_end		= 0x4804007f,
		.flags		= ADDR_TYPE_RT
	},
};

/* dss master ports */
static struct omap_hwmod_ocp_if *omap44xx_dss_masters[] = {
	&omap44xx_dss__l3_1,
};

/* l4_per -> dss */
static struct omap_hwmod_ocp_if omap44xx_l4_per__dss = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_dss_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_dss_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_dss_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_2 -> dss */
static struct omap_hwmod_ocp_if omap44xx_l3_2__dss = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_dss_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_dss_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_dss_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* dss slave ports */
static struct omap_hwmod_ocp_if *omap44xx_dss_slaves[] = {
	&omap44xx_l4_per__dss,
	&omap44xx_l3_2__dss,
};

static struct omap_hwmod_sysconfig omap44xx_dss_sysc = {
	.rev_offs	= 0x0000,
	.syss_offs	= 0x0014,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod_opt_clk dss_opt_clks[] = {
	{ .role = "tv_clk", .clkdev_con_id = "extalt_clkin_ck" },
	{ .role = "dssclk", .clkdev_con_id = "dpll_per_m5_ck" },
	{ .role = "sys_clk", .clkdev_con_id = "syc_clk_div_ck" },
	{ .role = "48mhz_clk", .clkdev_con_id = "func_48mc_fclk" },
};

static struct omap_hwmod omap44xx_dss_hwmod = {
	.name		= "dss",
	.mpu_irqs	= omap44xx_dss_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_dss_irqs),
	.sdma_chs	= omap44xx_dss_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_dss_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dss_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_DSS_MOD,
			.device_reg = OMAP4430_CM_DSS_DSS_CLKCTRL,
		},
	},
	.opt_clks 	= dss_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(dss_opt_clks),
	.sysconfig	= &omap44xx_dss_sysc,
	.slaves		= omap44xx_dss_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_dss_slaves),
	.masters	= omap44xx_dss_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_dss_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* fdif */
static struct omap_hwmod_irq_info omap44xx_fdif_irqs[] = {
	{ .name = "irq_3", .irq = OMAP44XX_IRQ_FDIF_3 }, /* 69 */
};

static struct omap_hwmod_addr_space omap44xx_fdif_addrs[] = {
	{
		.pa_start	= 0x4a10a000,
		.pa_end		= 0x4a10a1ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* fdif master ports */
static struct omap_hwmod_ocp_if *omap44xx_fdif_masters[] = {
	&omap44xx_fdif__l3_2,
};

/* l4_cfg -> fdif */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__fdif = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_fdif_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_fdif_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_fdif_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* fdif slave ports */
static struct omap_hwmod_ocp_if *omap44xx_fdif_slaves[] = {
	&omap44xx_l4_cfg__fdif,
};

static struct omap_hwmod_sysconfig omap44xx_fdif_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_MIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_fdif_hwmod = {
	.name		= "fdif",
	.mpu_irqs	= omap44xx_fdif_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_fdif_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "fdif_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CAM_MOD,
			.device_reg = OMAP4430_CM_CAM_FDIF_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_fdif_sysc,
	.slaves		= omap44xx_fdif_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_fdif_slaves),
	.masters	= omap44xx_fdif_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_fdif_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gfx */
static struct omap_hwmod_irq_info omap44xx_gfx_irqs[] = {
	{ .name = "irq", .irq = OMAP44XX_IRQ_GFX }, /* 21 */
};

static struct omap_hwmod_addr_space omap44xx_gfx_addrs[] = {
	{
		.pa_start	= 0x56000000,
		.pa_end		= 0x5600ffff,
		.flags		= ADDR_TYPE_RT
	},
};

/* gfx master ports */
static struct omap_hwmod_ocp_if *omap44xx_gfx_masters[] = {
	&omap44xx_gfx__l3_2,
};

/* l3_2 -> gfx */
static struct omap_hwmod_ocp_if omap44xx_l3_2__gfx = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_gfx_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_gfx_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gfx_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gfx slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gfx_slaves[] = {
	&omap44xx_l3_2__gfx,
};

static struct omap_hwmod_sysconfig omap44xx_gfx_sysc = {
	.rev_offs	= 0xfe00,
	.sysc_offs	= 0xfe10,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gfx_hwmod = {
	.name		= "gfx",
	.mpu_irqs	= omap44xx_gfx_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gfx_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gfx_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_GFX_MOD,
			.device_reg = OMAP4430_CM_GFX_GFX_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gfx_sysc,
	.slaves		= omap44xx_gfx_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gfx_slaves),
	.masters	= omap44xx_gfx_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_gfx_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* hsi */
static struct omap_hwmod_irq_info omap44xx_hsi_irqs[] = {
	{ .name = "hsi_p1_irq", .irq = OMAP44XX_IRQ_HSI_P2 }, /* 68 */
	{ .name = "hsi_dma_irq", .irq = OMAP44XX_IRQ_HSI_DMA }, /* 71 */
	{ .name = "hsi_p0_irq", .irq = OMAP44XX_IRQ_HSI_P1 }, /* 67 */
};

static struct omap_hwmod_addr_space omap44xx_hsi_addrs[] = {
	{
		.pa_start	= 0x4a05a000,
		.pa_end		= 0x4a05bfff,
		.flags		= ADDR_TYPE_RT
	},
};

/* hsi master ports */
static struct omap_hwmod_ocp_if *omap44xx_hsi_masters[] = {
	&omap44xx_hsi__l3_2,
};

/* l4_cfg -> hsi */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__hsi = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_hsi_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_hsi_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_hsi_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* hsi slave ports */
static struct omap_hwmod_ocp_if *omap44xx_hsi_slaves[] = {
	&omap44xx_l4_cfg__hsi,
};

static struct omap_hwmod_sysconfig omap44xx_hsi_sysc = {
	.sysc_flags	= SYSS_MISSING,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod omap44xx_hsi_hwmod = {
	.name		= "hsi",
	.mpu_irqs	= omap44xx_hsi_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_hsi_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "hsi_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_HSI_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_hsi_sysc,
	.slaves		= omap44xx_hsi_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_hsi_slaves),
	.masters	= omap44xx_hsi_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_hsi_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* iss */
static struct omap_hwmod_irq_info omap44xx_iss_irqs[] = {
	{ .name = "iss_irq", .irq = OMAP44XX_IRQ_ISS_5 }, /* 24 */
};

static struct omap_hwmod_dma_info omap44xx_iss_sdma_chs[] = {
	{ .name = "poupdmareqiss1", .dma_ch = OMAP44XX_DMA_ISS_REQ2 }, /* 9 */
	{ .name = "poupdmareqiss0", .dma_ch = OMAP44XX_DMA_ISS_REQ1 }, /* 8 */
	{ .name = "poupdmareqiss3", .dma_ch = OMAP44XX_DMA_ISS_REQ4 }, /* 12 */
	{ .name = "poupdmareqiss2", .dma_ch = OMAP44XX_DMA_ISS_REQ3 }, /* 11 */
};

static struct omap_hwmod_addr_space omap44xx_iss_addrs[] = {
	{
		.pa_start	= 0x52000000,
		.pa_end		= 0x520000ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* iss master ports */
static struct omap_hwmod_ocp_if *omap44xx_iss_masters[] = {
	&omap44xx_iss__l3_2,
};

/* l3_2 -> iss */
static struct omap_hwmod_ocp_if omap44xx_l3_2__iss = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_iss_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_iss_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_iss_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* iss slave ports */
static struct omap_hwmod_ocp_if *omap44xx_iss_slaves[] = {
	&omap44xx_l3_2__iss,
};

static struct omap_hwmod_sysconfig omap44xx_iss_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_MIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod_opt_clk iss_opt_clks[] = {
	{ .role = "ctrlclk", .clkdev_con_id = "func_96m_fclk" },
};

static struct omap_hwmod omap44xx_iss_hwmod = {
	.name		= "iss",
	.mpu_irqs	= omap44xx_iss_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_iss_irqs),
	.sdma_chs	= omap44xx_iss_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_iss_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "iss_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CAM_MOD,
			.device_reg = OMAP4430_CM_CAM_ISS_CLKCTRL,
		},
	},
	.opt_clks 	= iss_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(iss_opt_clks),
	.sysconfig	= &omap44xx_iss_sysc,
	.slaves		= omap44xx_iss_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_iss_slaves),
	.masters	= omap44xx_iss_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_iss_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* ivahd */
static struct omap_hwmod_irq_info omap44xx_ivahd_irqs[] = {
	{ .name = "pombint_0", .irq = OMAP44XX_IRQ_IVA_HD_POMBINTRPEND_0 }, /* 107 */
	{ .name = "posyncit_0", .irq = OMAP44XX_IRQ_IVA_HD_POSYNCITRPEND_0 }, /* 104 */
	{ .name = "posyncit_1", .irq = OMAP44XX_IRQ_IVA_HD_POSYNCITRPEND_1 }, /* 103 */
};

static struct omap_hwmod_addr_space omap44xx_ivahd_addrs[] = {
	{
		.pa_start	= 0x5a05a400,
		.pa_end		= 0x5a05a47f,
		.flags		= ADDR_TYPE_RT
	},
};

/* ivahd -> sl2 */
static struct omap_hwmod_ocp_if omap44xx_ivahd__sl2 = {
	.master		= &omap44xx_ivahd_hwmod,
	.slave		= &omap44xx_sl2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m5_ck",
	.addr		= omap44xx_ivahd_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_ivahd_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ivahd master ports */
static struct omap_hwmod_ocp_if *omap44xx_ivahd_masters[] = {
	&omap44xx_ivahd__l3_2,
	&omap44xx_ivahd__sl2,
	&omap44xx_ivahd__l3_instr,
};

/* tesla -> ivahd */
static struct omap_hwmod_ocp_if omap44xx_tesla__ivahd = {
	.master		= &omap44xx_tesla_hwmod,
	.slave		= &omap44xx_ivahd_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m4_ck",
	.addr		= omap44xx_ivahd_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_ivahd_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* l3_2 -> ivahd */
static struct omap_hwmod_ocp_if omap44xx_l3_2__ivahd = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_ivahd_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_ivahd_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_ivahd_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ivahd slave ports */
static struct omap_hwmod_ocp_if *omap44xx_ivahd_slaves[] = {
	&omap44xx_tesla__ivahd,
	&omap44xx_l3_2__ivahd,
};

static struct omap_hwmod_sysconfig omap44xx_ivahd_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_MIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_ivahd_hwmod = {
	.name		= "ivahd",
	.mpu_irqs	= omap44xx_ivahd_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_ivahd_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ivahd_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_IVAHD_MOD,
			.device_reg = OMAP4430_CM_IVAHD_IVAHD_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_ivahd_sysc,
	.slaves		= omap44xx_ivahd_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_ivahd_slaves),
	.masters	= omap44xx_ivahd_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_ivahd_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mmc1 */
static struct omap_hwmod_irq_info omap44xx_mmc1_irqs[] = {
	{ .name = "irq", .irq = OMAP44XX_IRQ_MMC1 }, /* 83 */
};

static struct omap_hwmod_dma_info omap44xx_mmc1_sdma_chs[] = {
	{ .name = "dma_tx", .dma_ch = OMAP44XX_DMA_MMC1_TX }, /* 60 */
	{ .name = "dma_rx", .dma_ch = OMAP44XX_DMA_MMC1_RX }, /* 61 */
};

static struct omap_hwmod_addr_space omap44xx_mmc1_addrs[] = {
	{
		.pa_start	= 0x4809c000,
		.pa_end		= 0x4809c3ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* mmc1 master ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc1_masters[] = {
	&omap44xx_mmc1__l3_1,
};

/* l4_per -> mmc1 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mmc1 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mmc1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mmc1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mmc1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc1_slaves[] = {
	&omap44xx_l4_per__mmc1,
};

static struct omap_hwmod_sysconfig omap44xx_mmc1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mmc1_hwmod = {
	.name		= "mmc1",
	.mpu_irqs	= omap44xx_mmc1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mmc1_irqs),
	.sdma_chs	= omap44xx_mmc1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mmc1_sdma_chs),
	.clkdev_dev_id	= "mmci-omap-hs.0",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_MMC1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mmc1_sysc,
	.slaves		= omap44xx_mmc1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mmc1_slaves),
	.masters	= omap44xx_mmc1_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_mmc1_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mmc2 */
static struct omap_hwmod_irq_info omap44xx_mmc2_irqs[] = {
	{ .name = "irq", .irq = OMAP44XX_IRQ_MMC2 }, /* 86 */
};

static struct omap_hwmod_dma_info omap44xx_mmc2_sdma_chs[] = {
	{ .name = "dma_tx", .dma_ch = OMAP44XX_DMA_MMC2_TX }, /* 46 */
	{ .name = "dma_rx", .dma_ch = OMAP44XX_DMA_MMC2_RX }, /* 47 */
};

static struct omap_hwmod_addr_space omap44xx_mmc2_addrs[] = {
	{
		.pa_start	= 0x480b4000,
		.pa_end		= 0x480b43ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* mmc2 master ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc2_masters[] = {
	&omap44xx_mmc2__l3_1,
};

/* l4_per -> mmc2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mmc2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mmc2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mmc2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mmc2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc2_slaves[] = {
	&omap44xx_l4_per__mmc2,
};

static struct omap_hwmod_sysconfig omap44xx_mmc2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mmc2_hwmod = {
	.name		= "mmc2",
	.mpu_irqs	= omap44xx_mmc2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mmc2_irqs),
	.sdma_chs	= omap44xx_mmc2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mmc2_sdma_chs),
	.clkdev_dev_id	= "mmci-omap-hs.1",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_MMC2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mmc2_sysc,
	.slaves		= omap44xx_mmc2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mmc2_slaves),
	.masters	= omap44xx_mmc2_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_mmc2_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* sad2d */
/* sad2d -> emif_fw */
static struct omap_hwmod_ocp_if omap44xx_sad2d__emif_fw = {
	.master		= &omap44xx_sad2d_hwmod,
	.slave		= &omap44xx_emif_fw_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sad2d master ports */
static struct omap_hwmod_ocp_if *omap44xx_sad2d_masters[] = {
	&omap44xx_sad2d__sad2d_fw,
	&omap44xx_sad2d__emif_fw,
};

/* l3_2 -> sad2d */
static struct omap_hwmod_ocp_if omap44xx_l3_2__sad2d = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_sad2d_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sad2d slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sad2d_slaves[] = {
	&omap44xx_l3_2__sad2d,
};

static struct omap_hwmod omap44xx_sad2d_hwmod = {
	.name		= "sad2d",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_D2D_SAD2D_CLKCTRL,
		},
	},
	.slaves		= omap44xx_sad2d_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sad2d_slaves),
	.masters	= omap44xx_sad2d_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_sad2d_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* unipro1 */
static struct omap_hwmod_irq_info omap44xx_unipro1_irqs[] = {
	{ .name = "irq", .irq = OMAP44XX_IRQ_UNIPRO1 }, /* 124 */
};

static struct omap_hwmod_addr_space omap44xx_unipro1_addrs[] = {
	{
		.pa_start	= 0x4a068000,
		.pa_end		= 0x4a0680ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* unipro1 master ports */
static struct omap_hwmod_ocp_if *omap44xx_unipro1_masters[] = {
	&omap44xx_unipro1__l3_2,
};

/* l4_cfg -> unipro1 */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__unipro1 = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_unipro1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_unipro1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_unipro1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* unipro1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_unipro1_slaves[] = {
	&omap44xx_l4_cfg__unipro1,
};

static struct omap_hwmod_sysconfig omap44xx_unipro1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod_opt_clk unipro1_opt_clks[] = {
	{ .role = "txphyclk", .clkdev_con_id = "dpll_unipro_m2x2_ck" },
};

static struct omap_hwmod omap44xx_unipro1_hwmod = {
	.name		= "unipro1",
	.mpu_irqs	= omap44xx_unipro1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_unipro1_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "unipro1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_UNIPRO1_CLKCTRL,
		},
	},
	.opt_clks 	= unipro1_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(unipro1_opt_clks),
	.sysconfig	= &omap44xx_unipro1_sysc,
	.slaves		= omap44xx_unipro1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_unipro1_slaves),
	.masters	= omap44xx_unipro1_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_unipro1_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usb_host */
static struct omap_hwmod_irq_info omap44xx_usb_host_irqs[] = {
	{ .name = "ehci_irq", .irq = OMAP44XX_IRQ_EHCI }, /* 77 */
	{ .name = "ohci_irq", .irq = OMAP44XX_IRQ_OHCI }, /* 76 */
};

/* usb_host master ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_host_masters[] = {
	&omap44xx_usb_host__l3_2,
};

/* l4_cfg -> usb_host */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__usb_host = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_usb_host_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_host slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_host_slaves[] = {
	&omap44xx_l4_cfg__usb_host,
};

static struct omap_hwmod_opt_clk usb_host_opt_clks[] = {
	{ .role = "hsic60m_p2_clk", .clkdev_con_id = "init_60m_fclk" },
	{ .role = "utmi_p2_clk", .clkdev_con_id = "utmi_p2_gfclk_ck" },
	{ .role = "utmi_p1_clk", .clkdev_con_id = "utmi_p1_gfclk_ck" },
	{ .role = "hsic60m_p1_clk", .clkdev_con_id = "init_60m_fclk" },
	{ .role = "hsic480m_p1_clk", .clkdev_con_id = "dpll_usb_m2_ck" },
	{ .role = "utmi_p3_clk", .clkdev_con_id = "init_60m_fclk" },
	{ .role = "hsic480m_p2_clk", .clkdev_con_id = "dpll_usb_m2_ck" },
	{ .role = "func48mclk", .clkdev_con_id = "func_48mc_fclk" },
};

static struct omap_hwmod omap44xx_usb_host_hwmod = {
	.name		= "usb_host",
	.mpu_irqs	= omap44xx_usb_host_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_usb_host_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "usb_host_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_USB_HOST_CLKCTRL,
		},
	},
	.opt_clks 	= usb_host_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(usb_host_opt_clks),
	.slaves		= omap44xx_usb_host_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usb_host_slaves),
	.masters	= omap44xx_usb_host_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_usb_host_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usb_host_fs */
static struct omap_hwmod_irq_info omap44xx_usb_host_fs_irqs[] = {
	{ .name = "mcnint", .irq = OMAP44XX_IRQ_FSUSB }, /* 89 */
	{ .name = "dmanint", .irq = OMAP44XX_IRQ_FSUSB_SMI }, /* 90 */
};

static struct omap_hwmod_addr_space omap44xx_usb_host_fs_addrs[] = {
	{
		.pa_start	= 0x4a0a9000,
		.pa_end		= 0x4a0a93ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* usb_host_fs master ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_host_fs_masters[] = {
	&omap44xx_usb_host_fs__l3_2,
};

/* l4_cfg -> usb_host_fs */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__usb_host_fs = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_usb_host_fs_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_usb_host_fs_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_usb_host_fs_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_host_fs slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_host_fs_slaves[] = {
	&omap44xx_l4_cfg__usb_host_fs,
};

/* The IP is not compliant to type1 / type2 scheme */
static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_usb_host_fs = {
	.midle_shift	= 4,
	.sidle_shift	= 2,
	.srst_shift	= 1,
};

static struct omap_hwmod_sysconfig omap44xx_usb_host_fs_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0210,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_MIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type_usb_host_fs,
};

static struct omap_hwmod omap44xx_usb_host_fs_hwmod = {
	.name		= "usb_host_fs",
	.mpu_irqs	= omap44xx_usb_host_fs_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_usb_host_fs_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "usb_host_fs_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_USB_HOST_FS_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_usb_host_fs_sysc,
	.slaves		= omap44xx_usb_host_fs_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usb_host_fs_slaves),
	.masters	= omap44xx_usb_host_fs_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_usb_host_fs_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usb_otg */
static struct omap_hwmod_irq_info omap44xx_usb_otg_irqs[] = {
	{ .name = "mcnint", .irq = OMAP44XX_IRQ_HS_USB_MC_N }, /* 92 */
	{ .name = "dmanint", .irq = OMAP44XX_IRQ_HS_USB_DMA_N }, /* 93 */
};

static struct omap_hwmod_addr_space omap44xx_usb_otg_addrs[] = {
	{
		.pa_start	= 0x4a0ab000,
		.pa_end		= 0x4a0ab003,
		.flags		= ADDR_TYPE_RT
	},
};

/* usb_otg master ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_otg_masters[] = {
	&omap44xx_usb_otg__l3_2,
};

/* l4_cfg -> usb_otg */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__usb_otg = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_usb_otg_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_usb_otg_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_usb_otg_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_otg slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_otg_slaves[] = {
	&omap44xx_l4_cfg__usb_otg,
};

static struct omap_hwmod_sysconfig omap44xx_usb_otg_sysc = {
	.sysc_flags	= SYSS_MISSING,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod_opt_clk usb_otg_opt_clks[] = {
	{ .role = "xclk", .clkdev_con_id = "otg_60m_gfclk_ck" },
};

static struct omap_hwmod omap44xx_usb_otg_hwmod = {
	.name		= "usb_otg",
	.mpu_irqs	= omap44xx_usb_otg_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_usb_otg_irqs),
	.clkdev_dev_id	= "musb_hdrc",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_USB_OTG_CLKCTRL,
		},
	},
	.opt_clks 	= usb_otg_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(usb_otg_opt_clks),
	.sysconfig	= &omap44xx_usb_otg_sysc,
	.slaves		= omap44xx_usb_otg_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usb_otg_slaves),
	.masters	= omap44xx_usb_otg_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_usb_otg_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};


/* processor_dma_engine category */

/* tesla */
/* tesla -> sl2 */
static struct omap_hwmod_ocp_if omap44xx_tesla__sl2 = {
	.master		= &omap44xx_tesla_hwmod,
	.slave		= &omap44xx_sl2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_iva_m5_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* tesla master ports */
static struct omap_hwmod_ocp_if *omap44xx_tesla_masters[] = {
	&omap44xx_tesla__l3_1,
	&omap44xx_tesla__l4_audio,
	&omap44xx_tesla__sl2,
	&omap44xx_tesla__ivahd,
};

/* l4_cfg -> tesla */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__tesla = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_tesla_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* tesla slave ports */
static struct omap_hwmod_ocp_if *omap44xx_tesla_slaves[] = {
	&omap44xx_l4_cfg__tesla,
};

static struct omap_hwmod omap44xx_tesla_hwmod = {
	.name		= "tesla",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "tesla_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_TESLA_MOD,
			.device_reg = OMAP4430_CM_TESLA_TESLA_CLKCTRL,
		},
	},
	.slaves		= omap44xx_tesla_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_tesla_slaves),
	.masters	= omap44xx_tesla_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_tesla_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};


/* dma_engine category */

/* cryptodma: Secure module, not supported yet*/

/* sdma */
static struct omap_hwmod_irq_info omap44xx_sdma_irqs[] = {
	{ .name = "irq_2", .irq = OMAP44XX_IRQ_SDMA_2 }, /* 14 */
	{ .name = "irq_3", .irq = OMAP44XX_IRQ_SDMA_3 }, /* 15 */
	{ .name = "irq_0", .irq = OMAP44XX_IRQ_SDMA_0 }, /* 12 */
	{ .name = "irq_1", .irq = OMAP44XX_IRQ_SDMA_1 }, /* 13 */
};

static struct omap_hwmod_addr_space omap44xx_sdma_addrs[] = {
	{
		.pa_start	= 0x4a056000,
		.pa_end		= 0x4a0560ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* sdma master ports */
static struct omap_hwmod_ocp_if *omap44xx_sdma_masters[] = {
	&omap44xx_sdma__l3_2,
};

/* l4_cfg -> sdma */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__sdma = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_sdma_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_sdma_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_sdma_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sdma slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sdma_slaves[] = {
	&omap44xx_l4_cfg__sdma,
};

static struct omap_hwmod_sysconfig omap44xx_sdma_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x002c,
	.syss_offs	= 0x0028,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_MIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
			   SYSC_HAS_EMUFREE | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_sdma_hwmod = {
	.name		= "sdma",
	.mpu_irqs	= omap44xx_sdma_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_sdma_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_SDMA_SDMA_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_sdma_sysc,
	.slaves		= omap44xx_sdma_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sdma_slaves),
	.masters	= omap44xx_sdma_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_sdma_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};


/* other category */

/* bandgap */
static struct omap_hwmod_opt_clk bandgap_opt_clks[] = {
	{ .role = "bgap_32k", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_bandgap_hwmod = {
	.name		= "bandgap",
	.prcm = {
		.omap4 = {
			.device_reg = OMAP4430_CM_WKUP_BANDGAP_CLKCTRL,
		},
	},
	.opt_clks 	= bandgap_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(bandgap_opt_clks),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* debug_logic */
/* debug_logic master ports */
static struct omap_hwmod_ocp_if *omap44xx_debug_logic_masters[] = {
	&omap44xx_debug_logic__l3_2,
};

/* l3_instr -> debug_logic */
static struct omap_hwmod_ocp_if omap44xx_l3_instr__debug_logic = {
	.master		= &omap44xx_l3_instr_hwmod,
	.slave		= &omap44xx_debug_logic_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* debug_logic slave ports */
static struct omap_hwmod_ocp_if *omap44xx_debug_logic_slaves[] = {
	&omap44xx_l3_instr__debug_logic,
};

static struct omap_hwmod omap44xx_debug_logic_hwmod = {
	.name		= "debug_logic",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "trace_clk_div_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_EMU_MOD,
			.device_reg = OMAP4430_CM_EMU_DEBUGSS_CLKCTRL,
		},
	},
	.slaves		= omap44xx_debug_logic_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_debug_logic_slaves),
	.masters	= omap44xx_debug_logic_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_debug_logic_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* dll */
static struct omap_hwmod_opt_clk dll_opt_clks[] = {
	{ .role = "dll_clk", .clkdev_con_id = "dll_clk_div_ck" },
};

static struct omap_hwmod omap44xx_dll_hwmod = {
	.name		= "dll",
	.prcm = {
		.omap4 = {
			.device_reg = OMAP4430_CM_MEMIF_DLL_CLKCTRL,
		},
	},
	.opt_clks 	= dll_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(dll_opt_clks),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mpu_local_prcm */
static struct omap_hwmod omap44xx_mpu_local_prcm_hwmod = {
	.name		= "mpu_local_prcm",
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* scrm */
static struct omap_hwmod omap44xx_scrm_hwmod;
static struct omap_hwmod_addr_space omap44xx_scrm_addrs[] = {
	{
		.pa_start	= 0x4a30a000,
		.pa_end		= 0x4a30a7ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> scrm */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__scrm = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_scrm_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_scrm_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_scrm_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* scrm slave ports */
static struct omap_hwmod_ocp_if *omap44xx_scrm_slaves[] = {
	&omap44xx_l4_wkup__scrm,
};

static struct omap_hwmod_sysconfig omap44xx_scrm_sysc = {
	.sysc_flags	= SYSS_MISSING,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod omap44xx_scrm_hwmod = {
	.name		= "scrm",
	.sysconfig	= &omap44xx_scrm_sysc,
	.slaves		= omap44xx_scrm_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_scrm_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* std_efuse */
static struct omap_hwmod omap44xx_std_efuse_hwmod = {
	.name		= "std_efuse",
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usb_utmi_phy */
static struct omap_hwmod omap44xx_usb_utmi_phy_hwmod = {
	.name		= "usb_utmi_phy",
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};


/* slave_peripheral category */

/* aes1: Secure module, not supported yet*/

/* aes2: Secure module, not supported yet*/

/* attilacorectrl */
static struct omap_hwmod omap44xx_attilacorectrl_hwmod;
static struct omap_hwmod_addr_space omap44xx_attilacorectrl_addrs[] = {
	{
		.pa_start	= 0x4a002000,
		.pa_end		= 0x4a0027ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> attilacorectrl */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__attilacorectrl = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_attilacorectrl_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_attilacorectrl_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_attilacorectrl_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* attilacorectrl slave ports */
static struct omap_hwmod_ocp_if *omap44xx_attilacorectrl_slaves[] = {
	&omap44xx_l4_cfg__attilacorectrl,
};

static struct omap_hwmod omap44xx_attilacorectrl_hwmod = {
	.name		= "attilacorectrl",
	.slaves		= omap44xx_attilacorectrl_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_attilacorectrl_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* attilawakeupctrl */
static struct omap_hwmod omap44xx_attilawakeupctrl_hwmod;
static struct omap_hwmod_addr_space omap44xx_attilawakeupctrl_addrs[] = {
	{
		.pa_start	= 0x4a30c000,
		.pa_end		= 0x4a30c7ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> attilawakeupctrl */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__attilawakeupctrl = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_attilawakeupctrl_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_attilawakeupctrl_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_attilawakeupctrl_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* attilawakeupctrl slave ports */
static struct omap_hwmod_ocp_if *omap44xx_attilawakeupctrl_slaves[] = {
	&omap44xx_l4_wkup__attilawakeupctrl,
};

static struct omap_hwmod omap44xx_attilawakeupctrl_hwmod = {
	.name		= "attilawakeupctrl",
	.slaves		= omap44xx_attilawakeupctrl_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_attilawakeupctrl_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* cust_efuse */
static struct omap_hwmod omap44xx_cust_efuse_hwmod;
/* l4_cfg -> cust_efuse */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__cust_efuse = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_cust_efuse_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* cust_efuse slave ports */
static struct omap_hwmod_ocp_if *omap44xx_cust_efuse_slaves[] = {
	&omap44xx_l4_cfg__cust_efuse,
};

static struct omap_hwmod omap44xx_cust_efuse_hwmod = {
	.name		= "cust_efuse",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "cust_efuse_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CEFUSE_MOD,
			.device_reg = OMAP4430_CM_CEFUSE_CEFUSE_CLKCTRL,
		},
	},
	.slaves		= omap44xx_cust_efuse_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_cust_efuse_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* des3des: Secure module, not supported yet*/

/* devicecorectrl */
static struct omap_hwmod omap44xx_devicecorectrl_hwmod;
static struct omap_hwmod_addr_space omap44xx_devicecorectrl_addrs[] = {
	{
		.pa_start	= 0x4a100000,
		.pa_end		= 0x4a1007ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> devicecorectrl */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__devicecorectrl = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_devicecorectrl_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_devicecorectrl_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_devicecorectrl_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* devicecorectrl slave ports */
static struct omap_hwmod_ocp_if *omap44xx_devicecorectrl_slaves[] = {
	&omap44xx_l4_cfg__devicecorectrl,
};

static struct omap_hwmod_sysconfig omap44xx_devicecorectrl_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_devicecorectrl_hwmod = {
	.name		= "devicecorectrl",
	.sysconfig	= &omap44xx_devicecorectrl_sysc,
	.slaves		= omap44xx_devicecorectrl_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_devicecorectrl_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* devicewakeupctrl */
static struct omap_hwmod omap44xx_devicewakeupctrl_hwmod;
static struct omap_hwmod_addr_space omap44xx_devicewakeupctrl_addrs[] = {
	{
		.pa_start	= 0x4a31e000,
		.pa_end		= 0x4a31e7ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> devicewakeupctrl */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__devicewakeupctrl = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_devicewakeupctrl_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_devicewakeupctrl_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_devicewakeupctrl_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* devicewakeupctrl slave ports */
static struct omap_hwmod_ocp_if *omap44xx_devicewakeupctrl_slaves[] = {
	&omap44xx_l4_wkup__devicewakeupctrl,
};

static struct omap_hwmod_sysconfig omap44xx_devicewakeupctrl_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_devicewakeupctrl_hwmod = {
	.name		= "devicewakeupctrl",
	.sysconfig	= &omap44xx_devicewakeupctrl_sysc,
	.slaves		= omap44xx_devicewakeupctrl_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_devicewakeupctrl_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* dmic */
static struct omap_hwmod omap44xx_dmic_hwmod;
static struct omap_hwmod_irq_info omap44xx_dmic_irqs[] = {
	{ .name = "poupinterruptdmic", .irq = OMAP44XX_IRQ_DMIC }, /* 114 */
};

static struct omap_hwmod_dma_info omap44xx_dmic_sdma_chs[] = {
	{ .name = "poupdmareqdmic", .dma_ch = OMAP44XX_DMA_DMIC_REQ }, /* 66 */
};

static struct omap_hwmod_addr_space omap44xx_dmic_addrs[] = {
	{
		.pa_start	= 0x4012e000,
		.pa_end		= 0x4012e07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> dmic */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__dmic = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_dmic_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_dmic_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_dmic_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* dmic slave ports */
static struct omap_hwmod_ocp_if *omap44xx_dmic_slaves[] = {
	&omap44xx_l4_audio__dmic,
};

static struct omap_hwmod_sysconfig omap44xx_dmic_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_dmic_hwmod = {
	.name		= "dmic",
	.mpu_irqs	= omap44xx_dmic_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_dmic_irqs),
	.sdma_chs	= omap44xx_dmic_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_dmic_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dmic_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_DMIC_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_dmic_sysc,
	.slaves		= omap44xx_dmic_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_dmic_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* elm */
static struct omap_hwmod omap44xx_elm_hwmod;
static struct omap_hwmod_irq_info omap44xx_elm_irqs[] = {
	{ .name = "elmirq", .irq = OMAP44XX_IRQ_ELM }, /* 4 */
};

static struct omap_hwmod_addr_space omap44xx_elm_addrs[] = {
	{
		.pa_start	= 0x48078000,
		.pa_end		= 0x48078fff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> elm */
static struct omap_hwmod_ocp_if omap44xx_l4_per__elm = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_elm_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_elm_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_elm_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* elm slave ports */
static struct omap_hwmod_ocp_if *omap44xx_elm_slaves[] = {
	&omap44xx_l4_per__elm,
};

static struct omap_hwmod_sysconfig omap44xx_elm_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_elm_hwmod = {
	.name		= "elm",
	.mpu_irqs	= omap44xx_elm_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_elm_irqs),
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_ELM_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_elm_sysc,
	.slaves		= omap44xx_elm_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_elm_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* emif1 */
static struct omap_hwmod omap44xx_emif1_hwmod;
static struct omap_hwmod_irq_info omap44xx_emif1_irqs[] = {
	{ .name = "ll_err", .irq = OMAP44XX_IRQ_EMIF4_1 }, /* 110 */
};

static struct omap_hwmod_addr_space omap44xx_emif1_addrs[] = {
	{
		.pa_start	= 0x4c000000,
		.pa_end		= 0x4c0000ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* emif_fw -> emif1 */
static struct omap_hwmod_ocp_if omap44xx_emif_fw__emif1 = {
	.master		= &omap44xx_emif_fw_hwmod,
	.slave		= &omap44xx_emif1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_emif1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_emif1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* emif1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_emif1_slaves[] = {
	&omap44xx_emif_fw__emif1,
};

static struct omap_hwmod_sysconfig omap44xx_emif1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_flags	= SYSS_MISSING,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod omap44xx_emif1_hwmod = {
	.name		= "emif1",
	.mpu_irqs	= omap44xx_emif1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_emif1_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "emif1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_MEMIF_EMIF_1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_emif1_sysc,
	.slaves		= omap44xx_emif1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_emif1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* emif2 */
static struct omap_hwmod omap44xx_emif2_hwmod;
static struct omap_hwmod_irq_info omap44xx_emif2_irqs[] = {
	{ .name = "ll_err", .irq = OMAP44XX_IRQ_EMIF4_2 }, /* 111 */
};

static struct omap_hwmod_addr_space omap44xx_emif2_addrs[] = {
	{
		.pa_start	= 0x4d000000,
		.pa_end		= 0x4d0000ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* emif_fw -> emif2 */
static struct omap_hwmod_ocp_if omap44xx_emif_fw__emif2 = {
	.master		= &omap44xx_emif_fw_hwmod,
	.slave		= &omap44xx_emif2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_emif2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_emif2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* emif2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_emif2_slaves[] = {
	&omap44xx_emif_fw__emif2,
};

static struct omap_hwmod_sysconfig omap44xx_emif2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_flags	= SYSS_MISSING,
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
};

static struct omap_hwmod omap44xx_emif2_hwmod = {
	.name		= "emif2",
	.mpu_irqs	= omap44xx_emif2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_emif2_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "emif2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_MEMIF_EMIF_2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_emif2_sysc,
	.slaves		= omap44xx_emif2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_emif2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio1 */
static struct omap_hwmod omap44xx_gpio1_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio1_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO1 }, /* 29 */
};

static struct omap_hwmod_addr_space omap44xx_gpio1_addrs[] = {
	{
		.pa_start	= 0x4a310000,
		.pa_end		= 0x4a3101ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> gpio1 */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__gpio1 = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_gpio1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_gpio1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio1_slaves[] = {
	&omap44xx_l4_wkup__gpio1,
};

static struct omap_hwmod_sysconfig omap44xx_gpio1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio1_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio1_hwmod = {
	.name		= "gpio1",
	.mpu_irqs	= omap44xx_gpio1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio1_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_GPIO1_CLKCTRL,
		},
	},
	.opt_clks 	= gpio1_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio1_opt_clks),
	.sysconfig	= &omap44xx_gpio1_sysc,
	.slaves		= omap44xx_gpio1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio2 */
static struct omap_hwmod omap44xx_gpio2_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio2_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO2 }, /* 30 */
};

static struct omap_hwmod_addr_space omap44xx_gpio2_addrs[] = {
	{
		.pa_start	= 0x48055000,
		.pa_end		= 0x480551ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gpio2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gpio2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gpio2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gpio2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio2_slaves[] = {
	&omap44xx_l4_per__gpio2,
};

static struct omap_hwmod_sysconfig omap44xx_gpio2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio2_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio2_hwmod = {
	.name		= "gpio2",
	.mpu_irqs	= omap44xx_gpio2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio2_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_GPIO2_CLKCTRL,
		},
	},
	.opt_clks 	= gpio2_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio2_opt_clks),
	.sysconfig	= &omap44xx_gpio2_sysc,
	.slaves		= omap44xx_gpio2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio3 */
static struct omap_hwmod omap44xx_gpio3_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio3_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO3 }, /* 31 */
};

static struct omap_hwmod_addr_space omap44xx_gpio3_addrs[] = {
	{
		.pa_start	= 0x48057000,
		.pa_end		= 0x480571ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gpio3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gpio3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gpio3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gpio3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio3_slaves[] = {
	&omap44xx_l4_per__gpio3,
};

static struct omap_hwmod_sysconfig omap44xx_gpio3_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio3_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio3_hwmod = {
	.name		= "gpio3",
	.mpu_irqs	= omap44xx_gpio3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio3_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio3_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_GPIO3_CLKCTRL,
		},
	},
	.opt_clks 	= gpio3_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio3_opt_clks),
	.sysconfig	= &omap44xx_gpio3_sysc,
	.slaves		= omap44xx_gpio3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio4 */
static struct omap_hwmod omap44xx_gpio4_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio4_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO4 }, /* 32 */
};

static struct omap_hwmod_addr_space omap44xx_gpio4_addrs[] = {
	{
		.pa_start	= 0x48059000,
		.pa_end		= 0x480591ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gpio4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gpio4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gpio4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gpio4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio4_slaves[] = {
	&omap44xx_l4_per__gpio4,
};

static struct omap_hwmod_sysconfig omap44xx_gpio4_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio4_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio4_hwmod = {
	.name		= "gpio4",
	.mpu_irqs	= omap44xx_gpio4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio4_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio4_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_GPIO4_CLKCTRL,
		},
	},
	.opt_clks 	= gpio4_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio4_opt_clks),
	.sysconfig	= &omap44xx_gpio4_sysc,
	.slaves		= omap44xx_gpio4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio5 */
static struct omap_hwmod omap44xx_gpio5_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio5_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO5 }, /* 33 */
};

static struct omap_hwmod_addr_space omap44xx_gpio5_addrs[] = {
	{
		.pa_start	= 0x4805b000,
		.pa_end		= 0x4805b1ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gpio5 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gpio5 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gpio5_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gpio5_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio5_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio5 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio5_slaves[] = {
	&omap44xx_l4_per__gpio5,
};

static struct omap_hwmod_sysconfig omap44xx_gpio5_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio5_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio5_hwmod = {
	.name		= "gpio5",
	.mpu_irqs	= omap44xx_gpio5_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio5_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio5_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_GPIO5_CLKCTRL,
		},
	},
	.opt_clks 	= gpio5_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio5_opt_clks),
	.sysconfig	= &omap44xx_gpio5_sysc,
	.slaves		= omap44xx_gpio5_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio5_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpio6 */
static struct omap_hwmod omap44xx_gpio6_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpio6_irqs[] = {
	{ .name = "porocpsinterrupt1", .irq = OMAP44XX_IRQ_GPIO6 }, /* 34 */
};

static struct omap_hwmod_addr_space omap44xx_gpio6_addrs[] = {
	{
		.pa_start	= 0x4805d000,
		.pa_end		= 0x4805d1ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gpio6 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gpio6 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gpio6_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gpio6_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpio6_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpio6 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpio6_slaves[] = {
	&omap44xx_l4_per__gpio6,
};

static struct omap_hwmod_sysconfig omap44xx_gpio6_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk gpio6_opt_clks[] = {
	{ .role = "dbclk", .clkdev_con_id = "sys_32k_ck" },
};

static struct omap_hwmod omap44xx_gpio6_hwmod = {
	.name		= "gpio6",
	.mpu_irqs	= omap44xx_gpio6_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpio6_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpio6_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_GPIO6_CLKCTRL,
		},
	},
	.opt_clks 	= gpio6_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(gpio6_opt_clks),
	.sysconfig	= &omap44xx_gpio6_sysc,
	.slaves		= omap44xx_gpio6_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpio6_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gpmc */
static struct omap_hwmod omap44xx_gpmc_hwmod;
static struct omap_hwmod_irq_info omap44xx_gpmc_irqs[] = {
	{ .name = "gpmc_sinterrupt", .irq = OMAP44XX_IRQ_GPMC }, /* 20 */
};

static struct omap_hwmod_dma_info omap44xx_gpmc_sdma_chs[] = {
	{ .name = "gpmc_sdmareq_n", .dma_ch = OMAP44XX_DMA_GPMC }, /* 3 */
};

static struct omap_hwmod_addr_space omap44xx_gpmc_addrs[] = {
	{
		.pa_start	= 0x50000000,
		.pa_end		= 0x500003ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l3_2 -> gpmc */
static struct omap_hwmod_ocp_if omap44xx_l3_2__gpmc = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_gpmc_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.addr		= omap44xx_gpmc_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gpmc_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gpmc slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gpmc_slaves[] = {
	&omap44xx_l3_2__gpmc,
};

static struct omap_hwmod_sysconfig omap44xx_gpmc_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_gpmc_hwmod = {
	.name		= "gpmc",
	.mpu_irqs	= omap44xx_gpmc_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gpmc_irqs),
	.sdma_chs	= omap44xx_gpmc_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_gpmc_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gpmc_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_L3_2_GPMC_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gpmc_sysc,
	.slaves		= omap44xx_gpmc_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gpmc_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer1 */
static struct omap_hwmod omap44xx_gptimer1_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer1_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT1 }, /* 37 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer1_addrs[] = {
	{
		.pa_start	= 0x4a318000,
		.pa_end		= 0x4a31807f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> gptimer1 */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__gptimer1 = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_gptimer1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_gptimer1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer1_slaves[] = {
	&omap44xx_l4_wkup__gptimer1,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_EMUFREE | SYSC_HAS_AUTOIDLE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_gptimer1_hwmod = {
	.name		= "gptimer1",
	.mpu_irqs	= omap44xx_gptimer1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer1_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_TIMER1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer1_sysc,
	.slaves		= omap44xx_gptimer1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer10 */
static struct omap_hwmod omap44xx_gptimer10_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer10_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT10 }, /* 46 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer10_addrs[] = {
	{
		.pa_start	= 0x48086000,
		.pa_end		= 0x4808607f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer10 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer10 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer10_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer10_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer10_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer10 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer10_slaves[] = {
	&omap44xx_l4_per__gptimer10,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer10_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_EMUFREE | SYSC_HAS_AUTOIDLE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_gptimer10_hwmod = {
	.name		= "gptimer10",
	.mpu_irqs	= omap44xx_gptimer10_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer10_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer10_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER10_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer10_sysc,
	.slaves		= omap44xx_gptimer10_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer10_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer11 */
static struct omap_hwmod omap44xx_gptimer11_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer11_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT11 }, /* 47 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer11_addrs[] = {
	{
		.pa_start	= 0x48088000,
		.pa_end		= 0x4808807f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer11 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer11 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer11_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer11_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer11_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer11 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer11_slaves[] = {
	&omap44xx_l4_per__gptimer11,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer11_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer11_hwmod = {
	.name		= "gptimer11",
	.mpu_irqs	= omap44xx_gptimer11_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer11_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer11_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER11_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer11_sysc,
	.slaves		= omap44xx_gptimer11_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer11_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer12: Secure module, not supported yet*/

/* gptimer2 */
static struct omap_hwmod omap44xx_gptimer2_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer2_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT2 }, /* 38 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer2_addrs[] = {
	{
		.pa_start	= 0x48032000,
		.pa_end		= 0x4803207f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer2_slaves[] = {
	&omap44xx_l4_per__gptimer2,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_EMUFREE | SYSC_HAS_AUTOIDLE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_gptimer2_hwmod = {
	.name		= "gptimer2",
	.mpu_irqs	= omap44xx_gptimer2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer2_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer2_sysc,
	.slaves		= omap44xx_gptimer2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer3 */
static struct omap_hwmod omap44xx_gptimer3_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer3_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT3 }, /* 39 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer3_addrs[] = {
	{
		.pa_start	= 0x48034000,
		.pa_end		= 0x4803407f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer3_slaves[] = {
	&omap44xx_l4_per__gptimer3,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer3_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer3_hwmod = {
	.name		= "gptimer3",
	.mpu_irqs	= omap44xx_gptimer3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer3_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer3_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer3_sysc,
	.slaves		= omap44xx_gptimer3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer4 */
static struct omap_hwmod omap44xx_gptimer4_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer4_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT4 }, /* 40 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer4_addrs[] = {
	{
		.pa_start	= 0x48036000,
		.pa_end		= 0x4803607f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer4_slaves[] = {
	&omap44xx_l4_per__gptimer4,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer4_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer4_hwmod = {
	.name		= "gptimer4",
	.mpu_irqs	= omap44xx_gptimer4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer4_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer4_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer4_sysc,
	.slaves		= omap44xx_gptimer4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer5 */
static struct omap_hwmod omap44xx_gptimer5_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer5_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT5 }, /* 41 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer5_addrs[] = {
	{
		.pa_start	= 0x40138000,
		.pa_end		= 0x4013807f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> gptimer5 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__gptimer5 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_gptimer5_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_gptimer5_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer5_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer5 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer5_slaves[] = {
	&omap44xx_l4_audio__gptimer5,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer5_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer5_hwmod = {
	.name		= "gptimer5",
	.mpu_irqs	= omap44xx_gptimer5_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer5_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer5_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_TIMER5_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer5_sysc,
	.slaves		= omap44xx_gptimer5_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer5_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer6 */
static struct omap_hwmod omap44xx_gptimer6_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer6_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT6 }, /* 42 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer6_addrs[] = {
	{
		.pa_start	= 0x4013a000,
		.pa_end		= 0x4013a07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> gptimer6 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__gptimer6 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_gptimer6_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_gptimer6_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer6_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer6 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer6_slaves[] = {
	&omap44xx_l4_audio__gptimer6,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer6_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer6_hwmod = {
	.name		= "gptimer6",
	.mpu_irqs	= omap44xx_gptimer6_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer6_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer6_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_TIMER6_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer6_sysc,
	.slaves		= omap44xx_gptimer6_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer6_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer7 */
static struct omap_hwmod omap44xx_gptimer7_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer7_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT7 }, /* 43 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer7_addrs[] = {
	{
		.pa_start	= 0x4013c000,
		.pa_end		= 0x4013c07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> gptimer7 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__gptimer7 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_gptimer7_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_gptimer7_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer7_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer7 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer7_slaves[] = {
	&omap44xx_l4_audio__gptimer7,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer7_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer7_hwmod = {
	.name		= "gptimer7",
	.mpu_irqs	= omap44xx_gptimer7_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer7_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer7_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_TIMER7_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer7_sysc,
	.slaves		= omap44xx_gptimer7_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer7_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer8 */
static struct omap_hwmod omap44xx_gptimer8_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer8_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT8 }, /* 44 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer8_addrs[] = {
	{
		.pa_start	= 0x4013e000,
		.pa_end		= 0x4013e07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> gptimer8 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__gptimer8 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_gptimer8_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_gptimer8_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer8_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer8 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer8_slaves[] = {
	&omap44xx_l4_audio__gptimer8,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer8_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer8_hwmod = {
	.name		= "gptimer8",
	.mpu_irqs	= omap44xx_gptimer8_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer8_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer8_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_TIMER8_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer8_sysc,
	.slaves		= omap44xx_gptimer8_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer8_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* gptimer9 */
static struct omap_hwmod omap44xx_gptimer9_hwmod;
static struct omap_hwmod_irq_info omap44xx_gptimer9_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_GPT9 }, /* 45 */
};

static struct omap_hwmod_addr_space omap44xx_gptimer9_addrs[] = {
	{
		.pa_start	= 0x4803e000,
		.pa_end		= 0x4803e07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> gptimer9 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__gptimer9 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_gptimer9_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_gptimer9_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_gptimer9_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* gptimer9 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_gptimer9_slaves[] = {
	&omap44xx_l4_per__gptimer9,
};

static struct omap_hwmod_sysconfig omap44xx_gptimer9_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_gptimer9_hwmod = {
	.name		= "gptimer9",
	.mpu_irqs	= omap44xx_gptimer9_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_gptimer9_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "gptimer9_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_DMTIMER9_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_gptimer9_sysc,
	.slaves		= omap44xx_gptimer9_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_gptimer9_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* hdq1w */
static struct omap_hwmod omap44xx_hdq1w_hwmod;
static struct omap_hwmod_irq_info omap44xx_hdq1w_irqs[] = {
	{ .name = "hdqirq", .irq = OMAP44XX_IRQ_HDQ }, /* 58 */
};

static struct omap_hwmod_addr_space omap44xx_hdq1w_addrs[] = {
	{
		.pa_start	= 0x480b2000,
		.pa_end		= 0x480b201f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> hdq1w */
static struct omap_hwmod_ocp_if omap44xx_l4_per__hdq1w = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_hdq1w_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_hdq1w_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_hdq1w_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* hdq1w slave ports */
static struct omap_hwmod_ocp_if *omap44xx_hdq1w_slaves[] = {
	&omap44xx_l4_per__hdq1w,
};

static struct omap_hwmod_sysconfig omap44xx_hdq1w_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0014,
	.syss_offs	= 0x0018,
	.sysc_flags	= (SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_hdq1w_hwmod = {
	.name		= "hdq1w",
	.mpu_irqs	= omap44xx_hdq1w_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_hdq1w_irqs),
	.clkdev_dev_id	= "omap2_hdq.0",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_HDQ1W_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_hdq1w_sysc,
	.slaves		= omap44xx_hdq1w_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_hdq1w_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* i2c1 */
static struct omap_hwmod omap44xx_i2c1_hwmod;
static struct omap_hwmod_irq_info omap44xx_i2c1_irqs[] = {
	{ .name = "porocpintreq", .irq = OMAP44XX_IRQ_I2C1 }, /* 56 */
};

static struct omap_hwmod_dma_info omap44xx_i2c1_sdma_chs[] = {
	{ .name = "pordmarxreq", .dma_ch = OMAP44XX_DMA_I2C1_RX }, /* 27 */
	{ .name = "pordmatxreq", .dma_ch = OMAP44XX_DMA_I2C1_TX }, /* 26 */
};

static struct omap_hwmod_addr_space omap44xx_i2c1_addrs[] = {
	{
		.pa_start	= 0x48070000,
		.pa_end		= 0x480700ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> i2c1 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__i2c1 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_i2c1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_i2c1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_i2c1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* i2c1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_i2c1_slaves[] = {
	&omap44xx_l4_per__i2c1,
};

static struct omap_hwmod_sysconfig omap44xx_i2c1_sysc = {
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0090,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_i2c1_hwmod = {
	.name		= "i2c1",
	.mpu_irqs	= omap44xx_i2c1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_i2c1_irqs),
	.sdma_chs	= omap44xx_i2c1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_i2c1_sdma_chs),
	.clkdev_dev_id	= "i2c_omap.1",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_I2C1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_i2c1_sysc,
	.slaves		= omap44xx_i2c1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_i2c1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* i2c2 */
static struct omap_hwmod omap44xx_i2c2_hwmod;
static struct omap_hwmod_irq_info omap44xx_i2c2_irqs[] = {
	{ .name = "porocpintreq", .irq = OMAP44XX_IRQ_I2C2 }, /* 57 */
};

static struct omap_hwmod_dma_info omap44xx_i2c2_sdma_chs[] = {
	{ .name = "pordmarxreq", .dma_ch = OMAP44XX_DMA_I2C2_RX }, /* 29 */
	{ .name = "pordmatxreq", .dma_ch = OMAP44XX_DMA_I2C2_TX }, /* 28 */
};

static struct omap_hwmod_addr_space omap44xx_i2c2_addrs[] = {
	{
		.pa_start	= 0x48072000,
		.pa_end		= 0x480720ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> i2c2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__i2c2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_i2c2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_i2c2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_i2c2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* i2c2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_i2c2_slaves[] = {
	&omap44xx_l4_per__i2c2,
};

static struct omap_hwmod_sysconfig omap44xx_i2c2_sysc = {
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0090,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_i2c2_hwmod = {
	.name		= "i2c2",
	.mpu_irqs	= omap44xx_i2c2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_i2c2_irqs),
	.sdma_chs	= omap44xx_i2c2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_i2c2_sdma_chs),
	.clkdev_dev_id	= "i2c_omap.2",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_I2C2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_i2c2_sysc,
	.slaves		= omap44xx_i2c2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_i2c2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* i2c3 */
static struct omap_hwmod omap44xx_i2c3_hwmod;
static struct omap_hwmod_irq_info omap44xx_i2c3_irqs[] = {
	{ .name = "porocpintreq", .irq = OMAP44XX_IRQ_I2C3 }, /* 61 */
};

static struct omap_hwmod_dma_info omap44xx_i2c3_sdma_chs[] = {
	{ .name = "pordmarxreq", .dma_ch = OMAP44XX_DMA_I2C3_RX }, /* 25 */
	{ .name = "pordmatxreq", .dma_ch = OMAP44XX_DMA_I2C3_TX }, /* 24 */
};

static struct omap_hwmod_addr_space omap44xx_i2c3_addrs[] = {
	{
		.pa_start	= 0x48060000,
		.pa_end		= 0x480600ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> i2c3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__i2c3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_i2c3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_i2c3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_i2c3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* i2c3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_i2c3_slaves[] = {
	&omap44xx_l4_per__i2c3,
};

static struct omap_hwmod_sysconfig omap44xx_i2c3_sysc = {
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0090,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_i2c3_hwmod = {
	.name		= "i2c3",
	.mpu_irqs	= omap44xx_i2c3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_i2c3_irqs),
	.sdma_chs	= omap44xx_i2c3_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_i2c3_sdma_chs),
	.clkdev_dev_id	= "i2c_omap.3",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_I2C3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_i2c3_sysc,
	.slaves		= omap44xx_i2c3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_i2c3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* i2c4 */
static struct omap_hwmod omap44xx_i2c4_hwmod;
static struct omap_hwmod_irq_info omap44xx_i2c4_irqs[] = {
	{ .name = "porocpintreq", .irq = OMAP44XX_IRQ_I2C4 }, /* 62 */
};

static struct omap_hwmod_dma_info omap44xx_i2c4_sdma_chs[] = {
	{ .name = "pordmarxreq", .dma_ch = OMAP44XX_DMA_I2C4_RX }, /* 124 */
	{ .name = "pordmatxreq", .dma_ch = OMAP44XX_DMA_I2C4_TX }, /* 123 */
};

static struct omap_hwmod_addr_space omap44xx_i2c4_addrs[] = {
	{
		.pa_start	= 0x48350000,
		.pa_end		= 0x483500ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> i2c4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__i2c4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_i2c4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_i2c4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_i2c4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* i2c4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_i2c4_slaves[] = {
	&omap44xx_l4_per__i2c4,
};

static struct omap_hwmod_sysconfig omap44xx_i2c4_sysc = {
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0090,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_i2c4_hwmod = {
	.name		= "i2c4",
	.mpu_irqs	= omap44xx_i2c4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_i2c4_irqs),
	.sdma_chs	= omap44xx_i2c4_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_i2c4_sdma_chs),
	.clkdev_dev_id	= "i2c_omap.4",
	.clkdev_con_id	= "ick",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_I2C4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_i2c4_sysc,
	.slaves		= omap44xx_i2c4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_i2c4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* keyboard */
static struct omap_hwmod omap44xx_keyboard_hwmod;
static struct omap_hwmod_irq_info omap44xx_keyboard_irqs[] = {
	{ .name = "porocpsinterrupt", .irq = OMAP44XX_IRQ_KBD_CTL }, /* 120 */
};

static struct omap_hwmod_addr_space omap44xx_keyboard_addrs[] = {
	{
		.pa_start	= 0x4a31c000,
		.pa_end		= 0x4a31c07f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> keyboard */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__keyboard = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_keyboard_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_keyboard_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_keyboard_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* keyboard slave ports */
static struct omap_hwmod_ocp_if *omap44xx_keyboard_slaves[] = {
	&omap44xx_l4_wkup__keyboard,
};

static struct omap_hwmod_sysconfig omap44xx_keyboard_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_CLOCKACTIVITY |
			   SYSC_HAS_ENAWAKEUP | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_EMUFREE | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_keyboard_hwmod = {
	.name		= "keyboard",
	.mpu_irqs	= omap44xx_keyboard_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_keyboard_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "keyboard_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_KEYBOARD_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_keyboard_sysc,
	.slaves		= omap44xx_keyboard_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_keyboard_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mailbox */
static struct omap_hwmod omap44xx_mailbox_hwmod;
static struct omap_hwmod_irq_info omap44xx_mailbox_irqs[] = {
	{ .name = "irqn_0", .irq = OMAP44XX_IRQ_MAIL_U0 }, /* 26 */
};

static struct omap_hwmod_addr_space omap44xx_mailbox_addrs[] = {
	{
		.pa_start	= 0x4A0F4000,
		.pa_end		= 0x4A0F41FF,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> mailbox */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__mailbox = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_mailbox_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mailbox_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mailbox_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mailbox slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mailbox_slaves[] = {
	&omap44xx_l4_cfg__mailbox,
};

static struct omap_hwmod_sysconfig omap44xx_mailbox_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mailbox_hwmod = {
	.name		= "mailbox",
	.mpu_irqs	= omap44xx_mailbox_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mailbox_irqs),
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_L4CFG_MAILBOX_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mailbox_sysc,
	.slaves		= omap44xx_mailbox_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mailbox_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcasp */
static struct omap_hwmod omap44xx_mcasp_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcasp_irqs[] = {
	{ .name = "mcasp_x_intr", .irq = OMAP44XX_IRQ_MCASP1_AX }, /* 109 */
	{ .name = "mcasp_r_intr", .irq = OMAP44XX_IRQ_MCASP1_AR }, /* 108 */
};

static struct omap_hwmod_dma_info omap44xx_mcasp_sdma_chs[] = {
	{ .name = "mcasp_revent", .dma_ch = OMAP44XX_DMA_MCASP1_AREVT }, /* 10 */
	{ .name = "mcasp_xevent", .dma_ch = OMAP44XX_DMA_MCASP1_AXEVT }, /* 7 */
};

static struct omap_hwmod_addr_space omap44xx_mcasp_addrs[] = {
	{
		.pa_start	= 0x40128000,
		.pa_end		= 0x401283ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> mcasp */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__mcasp = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_mcasp_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_mcasp_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcasp_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcasp slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcasp_slaves[] = {
	&omap44xx_l4_audio__mcasp,
};

/* The IP is not compliant to type1 / type2 scheme */
static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_mcasp = {
	.sidle_shift	= 0,
};

static struct omap_hwmod_sysconfig omap44xx_mcasp_sysc = {
	.sysc_offs	= 0x0004,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type_mcasp,
};

static struct omap_hwmod omap44xx_mcasp_hwmod = {
	.name		= "mcasp",
	.mpu_irqs	= omap44xx_mcasp_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcasp_irqs),
	.sdma_chs	= omap44xx_mcasp_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcasp_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "mcasp_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_MCASP_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcasp_sysc,
	.slaves		= omap44xx_mcasp_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcasp_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcbsp1 */
static struct omap_hwmod omap44xx_mcbsp1_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcbsp1_irqs[] = {
	{ .name = "porcommonirq", .irq = OMAP44XX_IRQ_MCBSP1 }, /* 17 */
};

static struct omap_hwmod_dma_info omap44xx_mcbsp1_sdma_chs[] = {
	{ .name = "porxdmareq", .dma_ch = OMAP44XX_DMA_MCBSP1_TX }, /* 32 */
	{ .name = "porrdmareq", .dma_ch = OMAP44XX_DMA_MCBSP1_RX }, /* 33 */
};

static struct omap_hwmod_addr_space omap44xx_mcbsp1_addrs[] = {
	{
		.pa_start	= 0x40122000,
		.pa_end		= 0x401220ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> mcbsp1 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__mcbsp1 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_mcbsp1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_mcbsp1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcbsp1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcbsp1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcbsp1_slaves[] = {
	&omap44xx_l4_audio__mcbsp1,
};

static struct omap_hwmod_sysconfig omap44xx_mcbsp1_sysc = {
	.sysc_offs	= 0x008c,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_mcbsp1_hwmod = {
	.name		= "mcbsp1",
	.mpu_irqs	= omap44xx_mcbsp1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcbsp1_irqs),
	.sdma_chs	= omap44xx_mcbsp1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcbsp1_sdma_chs),
	.clkdev_dev_id	= "omap-mcbsp.1",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_MCBSP1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcbsp1_sysc,
	.slaves		= omap44xx_mcbsp1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcbsp1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcbsp2 */
static struct omap_hwmod omap44xx_mcbsp2_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcbsp2_irqs[] = {
	{ .name = "porcommonirq", .irq = OMAP44XX_IRQ_MCBSP2 }, /* 22 */
};

static struct omap_hwmod_dma_info omap44xx_mcbsp2_sdma_chs[] = {
	{ .name = "porxdmareq", .dma_ch = OMAP44XX_DMA_MCBSP2_TX }, /* 16 */
	{ .name = "porrdmareq", .dma_ch = OMAP44XX_DMA_MCBSP2_RX }, /* 17 */
};

static struct omap_hwmod_addr_space omap44xx_mcbsp2_addrs[] = {
	{
		.pa_start	= 0x40124000,
		.pa_end		= 0x401240ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> mcbsp2 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__mcbsp2 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_mcbsp2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_mcbsp2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcbsp2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcbsp2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcbsp2_slaves[] = {
	&omap44xx_l4_audio__mcbsp2,
};

static struct omap_hwmod_sysconfig omap44xx_mcbsp2_sysc = {
	.sysc_offs	= 0x008c,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_mcbsp2_hwmod = {
	.name		= "mcbsp2",
	.mpu_irqs	= omap44xx_mcbsp2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcbsp2_irqs),
	.sdma_chs	= omap44xx_mcbsp2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcbsp2_sdma_chs),
	.clkdev_dev_id	= "omap-mcbsp.2",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_MCBSP2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcbsp2_sysc,
	.slaves		= omap44xx_mcbsp2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcbsp2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcbsp3 */
static struct omap_hwmod omap44xx_mcbsp3_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcbsp3_irqs[] = {
	{ .name = "porcommonirq", .irq = OMAP44XX_IRQ_MCBSP3 }, /* 23 */
};

static struct omap_hwmod_dma_info omap44xx_mcbsp3_sdma_chs[] = {
	{ .name = "porxdmareq", .dma_ch = OMAP44XX_DMA_MCBSP3_TX }, /* 18 */
	{ .name = "porrdmareq", .dma_ch = OMAP44XX_DMA_MCBSP3_RX }, /* 19 */
};

static struct omap_hwmod_addr_space omap44xx_mcbsp3_addrs[] = {
	{
		.pa_start	= 0x40126000,
		.pa_end		= 0x401260ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> mcbsp3 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__mcbsp3 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_mcbsp3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_mcbsp3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcbsp3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcbsp3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcbsp3_slaves[] = {
	&omap44xx_l4_audio__mcbsp3,
};

static struct omap_hwmod_sysconfig omap44xx_mcbsp3_sysc = {
	.sysc_offs	= 0x008c,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_mcbsp3_hwmod = {
	.name		= "mcbsp3",
	.mpu_irqs	= omap44xx_mcbsp3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcbsp3_irqs),
	.sdma_chs	= omap44xx_mcbsp3_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcbsp3_sdma_chs),
	.clkdev_dev_id	= "omap-mcbsp.3",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_MCBSP3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcbsp3_sysc,
	.slaves		= omap44xx_mcbsp3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcbsp3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcbsp4 */
static struct omap_hwmod omap44xx_mcbsp4_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcbsp4_irqs[] = {
	{ .name = "porcommonirq", .irq = OMAP44XX_IRQ_MCBSP4 }, /* 16 */
};

static struct omap_hwmod_dma_info omap44xx_mcbsp4_sdma_chs[] = {
	{ .name = "porxdmareq", .dma_ch = OMAP44XX_DMA_MCBSP4_TX }, /* 30 */
	{ .name = "porrdmareq", .dma_ch = OMAP44XX_DMA_MCBSP4_RX }, /* 31 */
};

static struct omap_hwmod_addr_space omap44xx_mcbsp4_addrs[] = {
	{
		.pa_start	= 0x48096000,
		.pa_end		= 0x480960ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mcbsp4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mcbsp4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mcbsp4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mcbsp4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcbsp4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcbsp4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcbsp4_slaves[] = {
	&omap44xx_l4_per__mcbsp4,
};

static struct omap_hwmod_sysconfig omap44xx_mcbsp4_sysc = {
	.sysc_offs	= 0x008c,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_mcbsp4_hwmod = {
	.name		= "mcbsp4",
	.mpu_irqs	= omap44xx_mcbsp4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcbsp4_irqs),
	.sdma_chs	= omap44xx_mcbsp4_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcbsp4_sdma_chs),
	.clkdev_dev_id	= "omap-mcbsp.4",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MCBSP4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcbsp4_sysc,
	.slaves		= omap44xx_mcbsp4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcbsp4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcspi1 */
static struct omap_hwmod omap44xx_mcspi1_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcspi1_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_SPI1 }, /* 65 */
};

static struct omap_hwmod_dma_info omap44xx_mcspi1_sdma_chs[] = {
	{ .name = "ch0sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI1_TX0 }, /* 34 */
	{ .name = "ch2sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI1_TX2 }, /* 38 */
	{ .name = "ch1sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI1_RX1 }, /* 37 */
	{ .name = "ch1sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI1_TX1 }, /* 36 */
	{ .name = "ch0sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI1_RX0 }, /* 35 */
	{ .name = "ch2sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI1_RX2 }, /* 39 */
	{ .name = "ch3sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI1_RX3 }, /* 41 */
	{ .name = "ch3sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI1_TX3 }, /* 40 */
};

static struct omap_hwmod_addr_space omap44xx_mcspi1_addrs[] = {
	{
		.pa_start	= 0x48098000,
		.pa_end		= 0x480981ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mcspi1 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mcspi1 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mcspi1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mcspi1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcspi1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcspi1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcspi1_slaves[] = {
	&omap44xx_l4_per__mcspi1,
};

static struct omap_hwmod_sysconfig omap44xx_mcspi1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mcspi1_hwmod = {
	.name		= "mcspi1",
	.mpu_irqs	= omap44xx_mcspi1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcspi1_irqs),
	.sdma_chs	= omap44xx_mcspi1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcspi1_sdma_chs),
	.clkdev_dev_id	= "omap2_mcspi.1",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MCSPI1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcspi1_sysc,
	.slaves		= omap44xx_mcspi1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcspi1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcspi2 */
static struct omap_hwmod omap44xx_mcspi2_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcspi2_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_SPI2 }, /* 66 */
};

static struct omap_hwmod_dma_info omap44xx_mcspi2_sdma_chs[] = {
	{ .name = "ch0sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI2_TX0 }, /* 42 */
	{ .name = "ch1sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI2_TX1 }, /* 44 */
	{ .name = "ch0sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI2_RX0 }, /* 43 */
	{ .name = "ch1sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI2_RX1 }, /* 45 */
};

static struct omap_hwmod_addr_space omap44xx_mcspi2_addrs[] = {
	{
		.pa_start	= 0x4809a000,
		.pa_end		= 0x4809a1ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mcspi2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mcspi2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mcspi2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mcspi2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcspi2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcspi2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcspi2_slaves[] = {
	&omap44xx_l4_per__mcspi2,
};

static struct omap_hwmod_sysconfig omap44xx_mcspi2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mcspi2_hwmod = {
	.name		= "mcspi2",
	.mpu_irqs	= omap44xx_mcspi2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcspi2_irqs),
	.sdma_chs	= omap44xx_mcspi2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcspi2_sdma_chs),
	.clkdev_dev_id	= "omap2_mcspi.2",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MCSPI2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcspi2_sysc,
	.slaves		= omap44xx_mcspi2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcspi2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcspi3 */
static struct omap_hwmod omap44xx_mcspi3_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcspi3_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_SPI3 }, /* 91 */
};

static struct omap_hwmod_dma_info omap44xx_mcspi3_sdma_chs[] = {
	{ .name = "ch0sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI3_TX0 }, /* 14 */
	{ .name = "ch1sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI3_TX1 }, /* 22 */
	{ .name = "ch0sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI3_RX0 }, /* 15 */
	{ .name = "ch1sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI3_RX1 }, /* 23 */
};

static struct omap_hwmod_addr_space omap44xx_mcspi3_addrs[] = {
	{
		.pa_start	= 0x480b8000,
		.pa_end		= 0x480b81ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mcspi3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mcspi3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mcspi3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mcspi3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcspi3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcspi3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcspi3_slaves[] = {
	&omap44xx_l4_per__mcspi3,
};

static struct omap_hwmod_sysconfig omap44xx_mcspi3_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mcspi3_hwmod = {
	.name		= "mcspi3",
	.mpu_irqs	= omap44xx_mcspi3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcspi3_irqs),
	.sdma_chs	= omap44xx_mcspi3_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcspi3_sdma_chs),
	.clkdev_dev_id	= "omap2_mcspi.3",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MCSPI3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcspi3_sysc,
	.slaves		= omap44xx_mcspi3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcspi3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mcspi4 */
static struct omap_hwmod omap44xx_mcspi4_hwmod;
static struct omap_hwmod_irq_info omap44xx_mcspi4_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_SPI4 }, /* 48 */
};

static struct omap_hwmod_dma_info omap44xx_mcspi4_sdma_chs[] = {
	{ .name = "ch0sdmawreqn", .dma_ch = OMAP44XX_DMA_SPI4_TX0 }, /* 69 */
	{ .name = "ch0sdmarreqn", .dma_ch = OMAP44XX_DMA_SPI4_RX0 }, /* 70 */
};

static struct omap_hwmod_addr_space omap44xx_mcspi4_addrs[] = {
	{
		.pa_start	= 0x480ba000,
		.pa_end		= 0x480ba1ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mcspi4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mcspi4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mcspi4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mcspi4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mcspi4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mcspi4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mcspi4_slaves[] = {
	&omap44xx_l4_per__mcspi4,
};

static struct omap_hwmod_sysconfig omap44xx_mcspi4_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mcspi4_hwmod = {
	.name		= "mcspi4",
	.mpu_irqs	= omap44xx_mcspi4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mcspi4_irqs),
	.sdma_chs	= omap44xx_mcspi4_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mcspi4_sdma_chs),
	.clkdev_dev_id	= "omap2_mcspi.4",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MCSPI4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mcspi4_sysc,
	.slaves		= omap44xx_mcspi4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mcspi4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mmc3 */
static struct omap_hwmod omap44xx_mmc3_hwmod;
static struct omap_hwmod_irq_info omap44xx_mmc3_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_MMC3 }, /* 94 */
};

static struct omap_hwmod_dma_info omap44xx_mmc3_sdma_chs[] = {
	{ .name = "sdmawreqn", .dma_ch = OMAP44XX_DMA_MMC3_TX }, /* 76 */
	{ .name = "sdmarreqn", .dma_ch = OMAP44XX_DMA_MMC3_RX }, /* 77 */
};

static struct omap_hwmod_addr_space omap44xx_mmc3_addrs[] = {
	{
		.pa_start	= 0x480ad000,
		.pa_end		= 0x480ad3ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mmc3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mmc3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mmc3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mmc3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mmc3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc3_slaves[] = {
	&omap44xx_l4_per__mmc3,
};

static struct omap_hwmod_sysconfig omap44xx_mmc3_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mmc3_hwmod = {
	.name		= "mmc3",
	.mpu_irqs	= omap44xx_mmc3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mmc3_irqs),
	.sdma_chs	= omap44xx_mmc3_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mmc3_sdma_chs),
	.clkdev_dev_id	= "mmci-omap-hs.2",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MMCSD3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mmc3_sysc,
	.slaves		= omap44xx_mmc3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mmc3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mmc4 */
static struct omap_hwmod omap44xx_mmc4_hwmod;
static struct omap_hwmod_irq_info omap44xx_mmc4_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_MMC4 }, /* 96 */
};

static struct omap_hwmod_dma_info omap44xx_mmc4_sdma_chs[] = {
	{ .name = "sdmawreqn", .dma_ch = OMAP44XX_DMA_MMC4_TX }, /* 56 */
	{ .name = "sdmarreqn", .dma_ch = OMAP44XX_DMA_MMC4_RX }, /* 57 */
};

static struct omap_hwmod_addr_space omap44xx_mmc4_addrs[] = {
	{
		.pa_start	= 0x480d1000,
		.pa_end		= 0x480d13ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mmc4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mmc4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mmc4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mmc4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mmc4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc4_slaves[] = {
	&omap44xx_l4_per__mmc4,
};

static struct omap_hwmod_sysconfig omap44xx_mmc4_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mmc4_hwmod = {
	.name		= "mmc4",
	.mpu_irqs	= omap44xx_mmc4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mmc4_irqs),
	.sdma_chs	= omap44xx_mmc4_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mmc4_sdma_chs),
	.clkdev_dev_id	= "mmci-omap-hs.3",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MMCSD4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mmc4_sysc,
	.slaves		= omap44xx_mmc4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mmc4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mmc5 */
static struct omap_hwmod omap44xx_mmc5_hwmod;
static struct omap_hwmod_irq_info omap44xx_mmc5_irqs[] = {
	{ .name = "sinterruptn", .irq = OMAP44XX_IRQ_MMC5 }, /* 59 */
};

static struct omap_hwmod_dma_info omap44xx_mmc5_sdma_chs[] = {
	{ .name = "sdmawreqn", .dma_ch = OMAP44XX_DMA_MMC5_TX }, /* 58 */
	{ .name = "sdmarreqn", .dma_ch = OMAP44XX_DMA_MMC5_RX }, /* 59 */
};

static struct omap_hwmod_addr_space omap44xx_mmc5_addrs[] = {
	{
		.pa_start	= 0x480d5000,
		.pa_end		= 0x480d53ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> mmc5 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__mmc5 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_mmc5_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_mmc5_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_mmc5_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* mmc5 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_mmc5_slaves[] = {
	&omap44xx_l4_per__mmc5,
};

static struct omap_hwmod_sysconfig omap44xx_mmc5_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0114,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_MIDLEMODE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART |
			   MSTANDBY_FORCE | MSTANDBY_NO | MSTANDBY_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_mmc5_hwmod = {
	.name		= "mmc5",
	.mpu_irqs	= omap44xx_mmc5_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_mmc5_irqs),
	.sdma_chs	= omap44xx_mmc5_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_mmc5_sdma_chs),
	.clkdev_dev_id	= "mmci-omap-hs.4",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_MMCSD5_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_mmc5_sysc,
	.slaves		= omap44xx_mmc5_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_mmc5_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* ocmc_ram */
static struct omap_hwmod omap44xx_ocmc_ram_hwmod;
/* l3_2 -> ocmc_ram */
static struct omap_hwmod_ocp_if omap44xx_l3_2__ocmc_ram = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_ocmc_ram_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ocmc_ram slave ports */
static struct omap_hwmod_ocp_if *omap44xx_ocmc_ram_slaves[] = {
	&omap44xx_l3_2__ocmc_ram,
};

static struct omap_hwmod omap44xx_ocmc_ram_hwmod = {
	.name		= "ocmc_ram",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_L3_2_OCMC_RAM_CLKCTRL,
		},
	},
	.slaves		= omap44xx_ocmc_ram_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_ocmc_ram_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* pdm */
static struct omap_hwmod omap44xx_pdm_hwmod;
static struct omap_hwmod_irq_info omap44xx_pdm_irqs[] = {
	{ .name = "pointerruptmcpdm", .irq = OMAP44XX_IRQ_MCPDM }, /* 112 */
};

static struct omap_hwmod_dma_info omap44xx_pdm_sdma_chs[] = {
	{ .name = "poupdmareqmcpdm", .dma_ch = OMAP44XX_DMA_MCPDM_UP }, /* 64 */
	{ .name = "podldmareqmcpdm", .dma_ch = OMAP44XX_DMA_MCPDM_DL }, /* 65 */
};

static struct omap_hwmod_addr_space omap44xx_pdm_addrs[] = {
	{
		.pa_start	= 0x40132000,
		.pa_end		= 0x4013207f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> pdm */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__pdm = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_pdm_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_pdm_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_pdm_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* pdm slave ports */
static struct omap_hwmod_ocp_if *omap44xx_pdm_slaves[] = {
	&omap44xx_l4_audio__pdm,
};

static struct omap_hwmod_sysconfig omap44xx_pdm_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod omap44xx_pdm_hwmod = {
	.name		= "pdm",
	.mpu_irqs	= omap44xx_pdm_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_pdm_irqs),
	.sdma_chs	= omap44xx_pdm_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_pdm_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "pdm_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_PDM_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_pdm_sysc,
	.slaves		= omap44xx_pdm_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_pdm_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* pkaeip29: Secure module, not supported yet*/

/* rng: Secure module, not supported yet*/

/* sar_ram: Secure module, not supported yet*/

/* sar_rom: Secure module, not supported yet*/

/* sha2md51: Secure module, not supported yet*/

/* sl2 */
/* l3_2 -> sl2 */
static struct omap_hwmod_ocp_if omap44xx_l3_2__sl2 = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_sl2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sl2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sl2_slaves[] = {
	&omap44xx_tesla__sl2,
	&omap44xx_l3_2__sl2,
	&omap44xx_ivahd__sl2,
};

static struct omap_hwmod omap44xx_sl2_hwmod = {
	.name		= "sl2",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "sl2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_IVAHD_MOD,
			.device_reg = OMAP4430_CM_IVAHD_SL2_CLKCTRL,
		},
	},
	.slaves		= omap44xx_sl2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sl2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* slimbus1 */
static struct omap_hwmod omap44xx_slimbus1_hwmod;
static struct omap_hwmod_irq_info omap44xx_slimbus1_irqs[] = {
	{ .name = "po_sb_irq_n", .irq = OMAP44XX_IRQ_SLIMBUS1 }, /* 97 */
};

static struct omap_hwmod_dma_info omap44xx_slimbus1_sdma_chs[] = {
	{ .name = "po_rx_dma_1", .dma_ch = OMAP44XX_DMA_SLIMBUS1_RX1 }, /* 89 */
	{ .name = "po_rx_dma_0", .dma_ch = OMAP44XX_DMA_SLIMBUS1_RX0 }, /* 88 */
	{ .name = "po_rx_dma_3", .dma_ch = OMAP44XX_DMA_SLIMBUS1_RX3 }, /* 91 */
	{ .name = "po_rx_dma_2", .dma_ch = OMAP44XX_DMA_SLIMBUS1_RX2 }, /* 90 */
	{ .name = "po_tx_dma_3", .dma_ch = OMAP44XX_DMA_SLIMBUS1_TX3 }, /* 87 */
	{ .name = "po_tx_dma_2", .dma_ch = OMAP44XX_DMA_SLIMBUS1_TX2 }, /* 86 */
	{ .name = "po_tx_dma_1", .dma_ch = OMAP44XX_DMA_SLIMBUS1_TX1 }, /* 85 */
	{ .name = "po_tx_dma_0", .dma_ch = OMAP44XX_DMA_SLIMBUS1_TX0 }, /* 84 */
};

static struct omap_hwmod_addr_space omap44xx_slimbus1_addrs[] = {
	{
		.pa_start	= 0x4012c000,
		.pa_end		= 0x4012c0ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> slimbus1 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__slimbus1 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_slimbus1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_slimbus1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_slimbus1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* slimbus1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_slimbus1_slaves[] = {
	&omap44xx_l4_audio__slimbus1,
};

static struct omap_hwmod_sysconfig omap44xx_slimbus1_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod_opt_clk slimbus1_opt_clks[] = {
	{ .role = "slimbus_clk_11_11", .clkdev_con_id = "slimbus_clk" },
	{ .role = "fclk0", .clkdev_con_id = "abe_24m_fclk" },
	{ .role = "fclk1", .clkdev_con_id = "func_24m_clk" },
	{ .role = "fclk2", .clkdev_con_id = "pad_clks_ck" },
};

static struct omap_hwmod omap44xx_slimbus1_hwmod = {
	.name		= "slimbus1",
	.mpu_irqs	= omap44xx_slimbus1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_slimbus1_irqs),
	.sdma_chs	= omap44xx_slimbus1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_slimbus1_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "slimbus1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_SLIMBUS_CLKCTRL,
		},
	},
	.opt_clks 	= slimbus1_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(slimbus1_opt_clks),
	.sysconfig	= &omap44xx_slimbus1_sysc,
	.slaves		= omap44xx_slimbus1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_slimbus1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* slimbus2 */
static struct omap_hwmod omap44xx_slimbus2_hwmod;
static struct omap_hwmod_irq_info omap44xx_slimbus2_irqs[] = {
	{ .name = "po_sb_irq_n", .irq = OMAP44XX_IRQ_SLIMBUS2 }, /* 98 */
};

static struct omap_hwmod_dma_info omap44xx_slimbus2_sdma_chs[] = {
	{ .name = "po_rx_dma_1", .dma_ch = OMAP44XX_DMA_SLIMBUS2_RX1 }, /* 97 */
	{ .name = "po_rx_dma_0", .dma_ch = OMAP44XX_DMA_SLIMBUS2_RX0 }, /* 96 */
	{ .name = "po_rx_dma_3", .dma_ch = OMAP44XX_DMA_SLIMBUS2_RX3 }, /* 99 */
	{ .name = "po_rx_dma_2", .dma_ch = OMAP44XX_DMA_SLIMBUS2_RX2 }, /* 98 */
	{ .name = "po_tx_dma_3", .dma_ch = OMAP44XX_DMA_SLIMBUS2_TX3 }, /* 95 */
	{ .name = "po_tx_dma_2", .dma_ch = OMAP44XX_DMA_SLIMBUS2_TX2 }, /* 94 */
	{ .name = "po_tx_dma_1", .dma_ch = OMAP44XX_DMA_SLIMBUS2_TX1 }, /* 93 */
	{ .name = "po_tx_dma_0", .dma_ch = OMAP44XX_DMA_SLIMBUS2_TX0 }, /* 92 */
};

static struct omap_hwmod_addr_space omap44xx_slimbus2_addrs[] = {
	{
		.pa_start	= 0x48076000,
		.pa_end		= 0x480760ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> slimbus2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__slimbus2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_slimbus2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_slimbus2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_slimbus2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* slimbus2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_slimbus2_slaves[] = {
	&omap44xx_l4_per__slimbus2,
};

static struct omap_hwmod_sysconfig omap44xx_slimbus2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_SOFTRESET |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type2,
};

static struct omap_hwmod_opt_clk slimbus2_opt_clks[] = {
	{ .role = "perabe24m_gfclk", .clkdev_con_id = "per_abe_24m_fclk" },
	{ .role = "slimbus_clk", .clkdev_con_id = "pad_slimbus_core_clks_ck" },
	{ .role = "per24mc_gfclk", .clkdev_con_id = "func_24mc_fclk" },
};

static struct omap_hwmod omap44xx_slimbus2_hwmod = {
	.name		= "slimbus2",
	.mpu_irqs	= omap44xx_slimbus2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_slimbus2_irqs),
	.sdma_chs	= omap44xx_slimbus2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_slimbus2_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "slimbus2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_SLIMBUS2_CLKCTRL,
		},
	},
	.opt_clks 	= slimbus2_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(slimbus2_opt_clks),
	.sysconfig	= &omap44xx_slimbus2_sysc,
	.slaves		= omap44xx_slimbus2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_slimbus2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* spinlock */
static struct omap_hwmod omap44xx_spinlock_hwmod;
static struct omap_hwmod_addr_space omap44xx_spinlock_addrs[] = {
	{
		.pa_start	= 0x4a0f6000,
		.pa_end		= 0x4a0f6fff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> spinlock */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__spinlock = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_spinlock_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_spinlock_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_spinlock_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* spinlock slave ports */
static struct omap_hwmod_ocp_if *omap44xx_spinlock_slaves[] = {
	&omap44xx_l4_cfg__spinlock,
};

static struct omap_hwmod_sysconfig omap44xx_spinlock_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_spinlock_hwmod = {
	.name		= "spinlock",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_L4CFG_HW_SEM_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_spinlock_sysc,
	.slaves		= omap44xx_spinlock_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_spinlock_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* sr_core */
static struct omap_hwmod omap44xx_sr_core_hwmod;
static struct omap_hwmod_irq_info omap44xx_sr_core_irqs[] = {
	{ .name = "sinterruptz", .irq = OMAP44XX_IRQ_SR_CORE }, /* 19 */
};

static struct omap_hwmod_addr_space omap44xx_sr_core_addrs[] = {
	{
		.pa_start	= 0x4a0dd000,
		.pa_end		= 0x4a0dd03f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> sr_core */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__sr_core = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_sr_core_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_sr_core_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_sr_core_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sr_core slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sr_core_slaves[] = {
	&omap44xx_l4_cfg__sr_core,
};

/* The IP is not compliant to type1 / type2 scheme */
static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_sr_core = {
	.sidle_shift	= 24,
	.enwkup_shift	= 26,
};

static struct omap_hwmod_sysconfig omap44xx_sr_core_sysc = {
	.sysc_offs	= 0x0038,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type_sr_core,
};

static struct omap_hwmod omap44xx_sr_core_hwmod = {
	.name		= "sr_core",
	.mpu_irqs	= omap44xx_sr_core_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_sr_core_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "sr_core_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_ALWAYS_ON_MOD,
			.device_reg = OMAP4430_CM_ALWON_SR_CORE_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_sr_core_sysc,
	.slaves		= omap44xx_sr_core_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sr_core_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* sr_iva */
static struct omap_hwmod omap44xx_sr_iva_hwmod;
static struct omap_hwmod_irq_info omap44xx_sr_iva_irqs[] = {
	{ .name = "sinterruptz", .irq = OMAP44XX_IRQ_SR_IVA }, /* 102 */
};

static struct omap_hwmod_addr_space omap44xx_sr_iva_addrs[] = {
	{
		.pa_start	= 0x4a0db000,
		.pa_end		= 0x4a0db03f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> sr_iva */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__sr_iva = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_sr_iva_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_sr_iva_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_sr_iva_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sr_iva slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sr_iva_slaves[] = {
	&omap44xx_l4_cfg__sr_iva,
};

/* The IP is not compliant to type1 / type2 scheme */
static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_sr_iva = {
	.sidle_shift	= 24,
	.enwkup_shift	= 26,
};

static struct omap_hwmod_sysconfig omap44xx_sr_iva_sysc = {
	.sysc_offs	= 0x0038,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type_sr_iva,
};

static struct omap_hwmod omap44xx_sr_iva_hwmod = {
	.name		= "sr_iva",
	.mpu_irqs	= omap44xx_sr_iva_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_sr_iva_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "sr_iva_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_ALWAYS_ON_MOD,
			.device_reg = OMAP4430_CM_ALWON_SR_IVA_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_sr_iva_sysc,
	.slaves		= omap44xx_sr_iva_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sr_iva_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* sr_mpu */
static struct omap_hwmod omap44xx_sr_mpu_hwmod;
static struct omap_hwmod_irq_info omap44xx_sr_mpu_irqs[] = {
	{ .name = "sinterruptz", .irq = OMAP44XX_IRQ_SR_MCU }, /* 18 */
};

static struct omap_hwmod_addr_space omap44xx_sr_mpu_addrs[] = {
	{
		.pa_start	= 0x4a0d9000,
		.pa_end		= 0x4a0d903f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> sr_mpu */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__sr_mpu = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_sr_mpu_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_sr_mpu_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_sr_mpu_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* sr_mpu slave ports */
static struct omap_hwmod_ocp_if *omap44xx_sr_mpu_slaves[] = {
	&omap44xx_l4_cfg__sr_mpu,
};

/* The IP is not compliant to type1 / type2 scheme */
static struct omap_hwmod_sysc_fields omap_hwmod_sysc_type_sr_mpu = {
	.sidle_shift	= 24,
	.enwkup_shift	= 26,
};

static struct omap_hwmod_sysconfig omap44xx_sr_mpu_sysc = {
	.sysc_offs	= 0x0038,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type_sr_mpu,
};

static struct omap_hwmod omap44xx_sr_mpu_hwmod = {
	.name		= "sr_mpu",
	.mpu_irqs	= omap44xx_sr_mpu_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_sr_mpu_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "sr_mpu_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_ALWAYS_ON_MOD,
			.device_reg = OMAP4430_CM_ALWON_SR_MPU_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_sr_mpu_sysc,
	.slaves		= omap44xx_sr_mpu_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_sr_mpu_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* synctimer */
static struct omap_hwmod omap44xx_synctimer_hwmod;
static struct omap_hwmod_addr_space omap44xx_synctimer_addrs[] = {
	{
		.pa_start	= 0x4a304000,
		.pa_end		= 0x4a30401f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> synctimer */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__synctimer = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_synctimer_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_synctimer_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_synctimer_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* synctimer slave ports */
static struct omap_hwmod_ocp_if *omap44xx_synctimer_slaves[] = {
	&omap44xx_l4_wkup__synctimer,
};

static struct omap_hwmod_sysconfig omap44xx_synctimer_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0004,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSS_MISSING),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_synctimer_hwmod = {
	.name		= "synctimer",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "sys_32k_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_SYNCTIMER_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_synctimer_sysc,
	.slaves		= omap44xx_synctimer_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_synctimer_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* uart1 */
static struct omap_hwmod omap44xx_uart1_hwmod;
static struct omap_hwmod_irq_info omap44xx_uart1_irqs[] = {
	{ .name = "nirq", .irq = OMAP44XX_IRQ_UART1 }, /* 72 */
};

static struct omap_hwmod_dma_info omap44xx_uart1_sdma_chs[] = {
	{ .name = "rx", .dma_ch = OMAP44XX_DMA_UART1_RX }, /* 49 */
	{ .name = "tx", .dma_ch = OMAP44XX_DMA_UART1_TX }, /* 48 */
};

static struct omap_hwmod_addr_space omap44xx_uart1_addrs[] = {
	{
		.pa_start	= 0x4806a000,
		.pa_end		= 0x4806a0ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> uart1 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__uart1 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_uart1_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_uart1_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_uart1_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* uart1 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_uart1_slaves[] = {
	&omap44xx_l4_per__uart1,
};

static struct omap_hwmod_sysconfig omap44xx_uart1_sysc = {
	.rev_offs	= 0x0050,
	.sysc_offs	= 0x0054,
	.syss_offs	= 0x0058,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_uart1_hwmod = {
	.name		= "uart1",
	.mpu_irqs	= omap44xx_uart1_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_uart1_irqs),
	.sdma_chs	= omap44xx_uart1_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_uart1_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "uart1_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_UART1_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_uart1_sysc,
	.slaves		= omap44xx_uart1_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_uart1_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* uart2 */
static struct omap_hwmod omap44xx_uart2_hwmod;
static struct omap_hwmod_irq_info omap44xx_uart2_irqs[] = {
	{ .name = "nirq", .irq = OMAP44XX_IRQ_UART2 }, /* 73 */
};

static struct omap_hwmod_dma_info omap44xx_uart2_sdma_chs[] = {
	{ .name = "rx", .dma_ch = OMAP44XX_DMA_UART2_RX }, /* 51 */
	{ .name = "tx", .dma_ch = OMAP44XX_DMA_UART2_TX }, /* 50 */
};

static struct omap_hwmod_addr_space omap44xx_uart2_addrs[] = {
	{
		.pa_start	= 0x4806c000,
		.pa_end		= 0x4806c0ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> uart2 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__uart2 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_uart2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_uart2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_uart2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* uart2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_uart2_slaves[] = {
	&omap44xx_l4_per__uart2,
};

static struct omap_hwmod_sysconfig omap44xx_uart2_sysc = {
	.rev_offs	= 0x0050,
	.sysc_offs	= 0x0054,
	.syss_offs	= 0x0058,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_uart2_hwmod = {
	.name		= "uart2",
	.mpu_irqs	= omap44xx_uart2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_uart2_irqs),
	.sdma_chs	= omap44xx_uart2_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_uart2_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "uart2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_UART2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_uart2_sysc,
	.slaves		= omap44xx_uart2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_uart2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* uart3 */
static struct omap_hwmod omap44xx_uart3_hwmod;
static struct omap_hwmod_irq_info omap44xx_uart3_irqs[] = {
	{ .name = "nirq", .irq = OMAP44XX_IRQ_UART3 }, /* 74 */
};

static struct omap_hwmod_dma_info omap44xx_uart3_sdma_chs[] = {
	{ .name = "rx", .dma_ch = OMAP44XX_DMA_UART3_RX }, /* 53 */
	{ .name = "tx", .dma_ch = OMAP44XX_DMA_UART3_TX }, /* 52 */
};

static struct omap_hwmod_addr_space omap44xx_uart3_addrs[] = {
	{
		.pa_start	= 0x48020000,
		.pa_end		= 0x480200ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> uart3 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__uart3 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_uart3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_uart3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_uart3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* uart3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_uart3_slaves[] = {
	&omap44xx_l4_per__uart3,
};

static struct omap_hwmod_sysconfig omap44xx_uart3_sysc = {
	.rev_offs	= 0x0050,
	.sysc_offs	= 0x0054,
	.syss_offs	= 0x0058,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_uart3_hwmod = {
	.name		= "uart3",
	.mpu_irqs	= omap44xx_uart3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_uart3_irqs),
	.sdma_chs	= omap44xx_uart3_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_uart3_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "uart3_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_UART3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_uart3_sysc,
	.slaves		= omap44xx_uart3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_uart3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* uart4 */
static struct omap_hwmod omap44xx_uart4_hwmod;
static struct omap_hwmod_irq_info omap44xx_uart4_irqs[] = {
	{ .name = "nirq", .irq = OMAP44XX_IRQ_UART4 }, /* 70 */
};

static struct omap_hwmod_dma_info omap44xx_uart4_sdma_chs[] = {
	{ .name = "rx", .dma_ch = OMAP44XX_DMA_UART4_RX }, /* 55 */
	{ .name = "tx", .dma_ch = OMAP44XX_DMA_UART4_TX }, /* 54 */
};

static struct omap_hwmod_addr_space omap44xx_uart4_addrs[] = {
	{
		.pa_start	= 0x4806e000,
		.pa_end		= 0x4806e0ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_per -> uart4 */
static struct omap_hwmod_ocp_if omap44xx_l4_per__uart4 = {
	.master		= &omap44xx_l4_per_hwmod,
	.slave		= &omap44xx_uart4_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_uart4_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_uart4_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* uart4 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_uart4_slaves[] = {
	&omap44xx_l4_per__uart4,
};

static struct omap_hwmod_sysconfig omap44xx_uart4_sysc = {
	.rev_offs	= 0x0050,
	.sysc_offs	= 0x0054,
	.syss_offs	= 0x0058,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_SOFTRESET | SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_uart4_hwmod = {
	.name		= "uart4",
	.mpu_irqs	= omap44xx_uart4_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_uart4_irqs),
	.sdma_chs	= omap44xx_uart4_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_uart4_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "uart4_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L4PER_MOD,
			.device_reg = OMAP4430_CM_L4PER_UART4_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_uart4_sysc,
	.slaves		= omap44xx_uart4_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_uart4_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usb_tll */
static struct omap_hwmod omap44xx_usb_tll_hwmod;
static struct omap_hwmod_irq_info omap44xx_usb_tll_irqs[] = {
	{ .name = "tll_irq_n", .irq = OMAP44XX_IRQ_TLL }, /* 78 */
};

static struct omap_hwmod_addr_space omap44xx_usb_tll_addrs[] = {
	{
		.pa_start	= 0x4a062000,
		.pa_end		= 0x4a0627ff,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_cfg -> usb_tll */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__usb_tll = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_usb_tll_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.addr		= omap44xx_usb_tll_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_usb_tll_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usb_tll slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usb_tll_slaves[] = {
	&omap44xx_l4_cfg__usb_tll,
};

static struct omap_hwmod_sysconfig omap44xx_usb_tll_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_ENAWAKEUP | SYSC_HAS_SIDLEMODE |
			   SYSC_HAS_CLOCKACTIVITY | SYSC_HAS_SOFTRESET |
			   SYSC_HAS_AUTOIDLE),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod_opt_clk usb_tll_opt_clks[] = {
	{ .role = "usb_ch1_clk", .clkdev_con_id = "init_60m_fclk" },
	{ .role = "usb_ch0_clk", .clkdev_con_id = "init_60m_fclk" },
	{ .role = "usb_ch2_clk", .clkdev_con_id = "init_60m_fclk" },
};

static struct omap_hwmod omap44xx_usb_tll_hwmod = {
	.name		= "usb_tll",
	.mpu_irqs	= omap44xx_usb_tll_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_usb_tll_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "usb_tll_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_USB_TLL_CLKCTRL,
		},
	},
	.opt_clks 	= usb_tll_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(usb_tll_opt_clks),
	.sysconfig	= &omap44xx_usb_tll_sysc,
	.slaves		= omap44xx_usb_tll_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usb_tll_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usbphyocp2scp */
static struct omap_hwmod omap44xx_usbphyocp2scp_hwmod;
/* l4_cfg -> usbphyocp2scp */
static struct omap_hwmod_ocp_if omap44xx_l4_cfg__usbphyocp2scp = {
	.master		= &omap44xx_l4_cfg_hwmod,
	.slave		= &omap44xx_usbphyocp2scp_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usbphyocp2scp slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usbphyocp2scp_slaves[] = {
	&omap44xx_l4_cfg__usbphyocp2scp,
};

static struct omap_hwmod_opt_clk usbphyocp2scp_opt_clks[] = {
	{ .role = "clk32k", .clkdev_con_id = "sys_32k_ck" },
	{ .role = "phy_48m", .clkdev_con_id = "func_48m_fclk" },
};

static struct omap_hwmod omap44xx_usbphyocp2scp_hwmod = {
	.name		= "usbphyocp2scp",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "usbphyocp2scp_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_L3INIT_MOD,
			.device_reg = OMAP4430_CM_L3INIT_USBPHYOCP2SCP_CLKCTRL,
		},
	},
	.opt_clks 	= usbphyocp2scp_opt_clks,
	.opt_clks_cnt = ARRAY_SIZE(usbphyocp2scp_opt_clks),
	.slaves		= omap44xx_usbphyocp2scp_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usbphyocp2scp_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* usim */
static struct omap_hwmod omap44xx_usim_hwmod;
static struct omap_hwmod_irq_info omap44xx_usim_irqs[] = {
	{ .name = "ponirq", .irq = OMAP44XX_IRQ_USIM }, /* 35 */
};

static struct omap_hwmod_dma_info omap44xx_usim_sdma_chs[] = {
	{ .name = "pordmawreq", .dma_ch = OMAP44XX_DMA_USIM_TX }, /* 78 */
	{ .name = "pordmarreq", .dma_ch = OMAP44XX_DMA_USIM_RX }, /* 79 */
};

static struct omap_hwmod_addr_space omap44xx_usim_addrs[] = {
	{
		.pa_start	= 0x4a324000,
		.pa_end		= 0x4a32407f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> usim */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__usim = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_usim_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_usim_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_usim_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* usim slave ports */
static struct omap_hwmod_ocp_if *omap44xx_usim_slaves[] = {
	&omap44xx_l4_wkup__usim,
};

static struct omap_hwmod omap44xx_usim_hwmod = {
	.name		= "usim",
	.mpu_irqs	= omap44xx_usim_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_usim_irqs),
	.sdma_chs	= omap44xx_usim_sdma_chs,
	.sdma_chs_cnt	= ARRAY_SIZE(omap44xx_usim_sdma_chs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "usim_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_USIM_CLKCTRL,
		},
	},
	.slaves		= omap44xx_usim_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_usim_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* wdt1: Secure module, not supported yet*/

/* wdt2 */
static struct omap_hwmod omap44xx_wdt2_hwmod;
static struct omap_hwmod_irq_info omap44xx_wdt2_irqs[] = {
	{ .name = "porocpsinterruptn", .irq = OMAP44XX_IRQ_WDT2 }, /* 80 */
};

static struct omap_hwmod_addr_space omap44xx_wdt2_addrs[] = {
	{
		.pa_start	= 0x4a314000,
		.pa_end		= 0x4a31407f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_wkup -> wdt2 */
static struct omap_hwmod_ocp_if omap44xx_l4_wkup__wdt2 = {
	.master		= &omap44xx_l4_wkup_hwmod,
	.slave		= &omap44xx_wdt2_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l4_wkup_clk_mux_ck",
	.addr		= omap44xx_wdt2_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_wdt2_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* wdt2 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_wdt2_slaves[] = {
	&omap44xx_l4_wkup__wdt2,
};

static struct omap_hwmod_sysconfig omap44xx_wdt2_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_wdt2_hwmod = {
	.name		= "wdt2",
	.mpu_irqs	= omap44xx_wdt2_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_wdt2_irqs),
	.clkdev_dev_id	= "omap_wdt",
	.clkdev_con_id	= "fck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_PRM_WKUP_MOD,
			.device_reg = OMAP4430_CM_WKUP_WDT2_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_wdt2_sysc,
	.slaves		= omap44xx_wdt2_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_wdt2_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* wdt3 */
static struct omap_hwmod omap44xx_wdt3_hwmod;
static struct omap_hwmod_irq_info omap44xx_wdt3_irqs[] = {
	{ .name = "porocpsinterruptn", .irq = OMAP44XX_IRQ_WDT3 }, /* 36 */
};

static struct omap_hwmod_addr_space omap44xx_wdt3_addrs[] = {
	{
		.pa_start	= 0x40130000,
		.pa_end		= 0x4013007f,
		.flags		= ADDR_TYPE_RT
	},
};

/* l4_audio -> wdt3 */
static struct omap_hwmod_ocp_if omap44xx_l4_audio__wdt3 = {
	.master		= &omap44xx_l4_audio_hwmod,
	.slave		= &omap44xx_wdt3_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ocp_abe_iclk",
	.addr		= omap44xx_wdt3_addrs,
	.addr_cnt	= ARRAY_SIZE(omap44xx_wdt3_addrs),
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* wdt3 slave ports */
static struct omap_hwmod_ocp_if *omap44xx_wdt3_slaves[] = {
	&omap44xx_l4_audio__wdt3,
};

static struct omap_hwmod_sysconfig omap44xx_wdt3_sysc = {
	.rev_offs	= 0x0000,
	.sysc_offs	= 0x0010,
	.syss_offs	= 0x0014,
	.sysc_flags	= (SYSC_HAS_SIDLEMODE | SYSC_HAS_EMUFREE |
			   SYSC_HAS_SOFTRESET),
	.idlemodes	= (SIDLE_FORCE | SIDLE_NO | SIDLE_SMART),
	.sysc_fields	= &omap_hwmod_sysc_type1,
};

static struct omap_hwmod omap44xx_wdt3_hwmod = {
	.name		= "wdt3",
	.mpu_irqs	= omap44xx_wdt3_irqs,
	.mpu_irqs_cnt	= ARRAY_SIZE(omap44xx_wdt3_irqs),
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "wdt3_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_ABE_MOD,
			.device_reg = OMAP4430_CM1_ABE_WDT3_CLKCTRL,
		},
	},
	.sysconfig	= &omap44xx_wdt3_sysc,
	.slaves		= omap44xx_wdt3_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_wdt3_slaves),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};


/* processor category */

/* cpu0 */
static struct omap_hwmod omap44xx_cpu0_hwmod = {
	.name		= "cpu0",
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* cpu1 */
static struct omap_hwmod omap44xx_cpu1_hwmod = {
	.name		= "cpu1",
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* ducati */
/* ducati master ports */
static struct omap_hwmod_ocp_if *omap44xx_ducati_masters[] = {
	&omap44xx_ducati__l3_2,
};

/* l3_2 -> ducati */
static struct omap_hwmod_ocp_if omap44xx_l3_2__ducati = {
	.master		= &omap44xx_l3_2_hwmod,
	.slave		= &omap44xx_ducati_hwmod,
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "l3_div_ck",
	.user		= OCP_USER_MPU | OCP_USER_SDMA,
};

/* ducati slave ports */
static struct omap_hwmod_ocp_if *omap44xx_ducati_slaves[] = {
	&omap44xx_l3_2__ducati,
};

static struct omap_hwmod omap44xx_ducati_hwmod = {
	.name		= "ducati",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "ducati_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM2_CORE_MOD,
			.device_reg = OMAP4430_CM_DUCATI_DUCATI_CLKCTRL,
		},
	},
	.slaves		= omap44xx_ducati_slaves,
	.slaves_cnt	= ARRAY_SIZE(omap44xx_ducati_slaves),
	.masters	= omap44xx_ducati_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_ducati_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

/* mpuss */
/* mpuss master ports */
static struct omap_hwmod_ocp_if *omap44xx_mpuss_masters[] = {
	&omap44xx_mpuss__l3_1,
	&omap44xx_mpuss__dmm,
	&omap44xx_mpuss__l4_audio,
};

static struct omap_hwmod omap44xx_mpuss_hwmod = {
	.name		= "mpuss",
	.clkdev_dev_id	= NULL,
	.clkdev_con_id	= "dpll_mpu_m2_ck",
	.prcm = {
		.omap4 = {
			.module_offs = OMAP4430_CM1_MPU_MOD,
			.device_reg = OMAP4430_CM_MPU_MPU_CLKCTRL,
		},
	},
	.masters	= omap44xx_mpuss_masters,
	.masters_cnt	= ARRAY_SIZE(omap44xx_mpuss_masters),
	.omap_chip	= OMAP_CHIP_INIT(CHIP_IS_OMAP4430),
};

static __initdata struct omap_hwmod *omap44xx_hwmods[] = {
	/* interconnect */
	&omap44xx_dmm_hwmod,
	&omap44xx_l3_instr_hwmod,
	&omap44xx_l3_1_hwmod,
	&omap44xx_l3_2_hwmod,
	&omap44xx_l3_3_hwmod,
	&omap44xx_l4_audio_hwmod,
	&omap44xx_l4_cfg_hwmod,
	&omap44xx_l4_per_hwmod,
	&omap44xx_l4_wkup_hwmod,
	&omap44xx_sad2d_fw_hwmod,

	/* processor_dma_engine */
	&omap44xx_tesla_hwmod,

	/* dma_engine */
	&omap44xx_sdma_hwmod,

	/* other */
	&omap44xx_bandgap_hwmod,
	&omap44xx_debug_logic_hwmod,
	&omap44xx_dll_hwmod,
	&omap44xx_mpu_local_prcm_hwmod,
	&omap44xx_scrm_hwmod,
	&omap44xx_std_efuse_hwmod,
	&omap44xx_usb_utmi_phy_hwmod,

	/* slave_peripheral */
	&omap44xx_attilacorectrl_hwmod,
	&omap44xx_attilawakeupctrl_hwmod,
	&omap44xx_cust_efuse_hwmod,
	&omap44xx_devicecorectrl_hwmod,
	&omap44xx_devicewakeupctrl_hwmod,
	&omap44xx_dmic_hwmod,
	&omap44xx_elm_hwmod,
	&omap44xx_emif1_hwmod,
	&omap44xx_emif2_hwmod,
	&omap44xx_gpio1_hwmod,
	&omap44xx_gpio2_hwmod,
	&omap44xx_gpio3_hwmod,
	&omap44xx_gpio4_hwmod,
	&omap44xx_gpio5_hwmod,
	&omap44xx_gpio6_hwmod,
#if 0
	&omap44xx_gpmc_hwmod,
#endif
	&omap44xx_gptimer1_hwmod,
	&omap44xx_gptimer10_hwmod,
	&omap44xx_gptimer11_hwmod,
	&omap44xx_gptimer2_hwmod,
	&omap44xx_gptimer3_hwmod,
	&omap44xx_gptimer4_hwmod,
	&omap44xx_gptimer5_hwmod,
	&omap44xx_gptimer6_hwmod,
	&omap44xx_gptimer7_hwmod,
	&omap44xx_gptimer8_hwmod,
	&omap44xx_gptimer9_hwmod,
#if 0
	&omap44xx_hdq1w_hwmod,
#endif
	&omap44xx_i2c1_hwmod,
	&omap44xx_i2c2_hwmod,
	&omap44xx_i2c3_hwmod,
	&omap44xx_i2c4_hwmod,
	&omap44xx_keyboard_hwmod,
#if 0
	&omap44xx_mailbox_hwmod,
	&omap44xx_mcasp_hwmod,
	&omap44xx_mcbsp1_hwmod,
	&omap44xx_mcbsp2_hwmod,
	&omap44xx_mcbsp3_hwmod,
	&omap44xx_mcbsp4_hwmod,
	&omap44xx_mcspi1_hwmod,
	&omap44xx_mcspi2_hwmod,
	&omap44xx_mcspi3_hwmod,
	&omap44xx_mcspi4_hwmod,
	&omap44xx_mmc3_hwmod,
	&omap44xx_mmc4_hwmod,
	&omap44xx_mmc5_hwmod,
	&omap44xx_ocmc_ram_hwmod,
#endif
	&omap44xx_pdm_hwmod,
#if 0
	&omap44xx_sl2_hwmod,
	&omap44xx_slimbus1_hwmod,
	&omap44xx_slimbus2_hwmod,
	&omap44xx_spinlock_hwmod,
	&omap44xx_sr_core_hwmod,
	&omap44xx_sr_iva_hwmod,
	&omap44xx_sr_mpu_hwmod,
	&omap44xx_synctimer_hwmod,
#endif
	&omap44xx_uart1_hwmod,
	&omap44xx_uart2_hwmod,
	&omap44xx_uart3_hwmod,
	&omap44xx_uart4_hwmod,
#if 0
	&omap44xx_usb_tll_hwmod,
	&omap44xx_usbphyocp2scp_hwmod,
	&omap44xx_usim_hwmod,
	&omap44xx_wdt2_hwmod,
	&omap44xx_wdt3_hwmod,
#endif

	&omap44xx_dss_hwmod,
#if 0
	/* master_peripheral */
	&omap44xx_aess_hwmod,
	&omap44xx_fdif_hwmod,
	&omap44xx_gfx_hwmod,
	&omap44xx_hsi_hwmod,
	&omap44xx_iss_hwmod,
	&omap44xx_ivahd_hwmod,
	&omap44xx_mmc1_hwmod,
	&omap44xx_mmc2_hwmod,
	&omap44xx_sad2d_hwmod,
	&omap44xx_unipro1_hwmod,
	&omap44xx_usb_host_hwmod,
	&omap44xx_usb_host_fs_hwmod,
	&omap44xx_usb_otg_hwmod,

	/* processor */
	&omap44xx_cpu0_hwmod,
	&omap44xx_cpu1_hwmod,
	&omap44xx_ducati_hwmod,
	&omap44xx_mpuss_hwmod,
#endif
	NULL,
};

#else
# define omap44xx_hwmods		0
#endif

#endif
